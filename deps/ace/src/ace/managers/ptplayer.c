/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// Info regarding MOD file format:
// - https://www.fileformat.info/format/mod/corion.htm
// - http://lclevy.free.fr/mo3/mod.txt
// - https://www.stef.be/bassoontracker/docs/ProtrackerCommandReference.pdf
// - http://coppershade.org/articles/More!/Topics/Protracker_Tempo
// - http://coppershade.org/articles/More!/Topics/Protracker_File_Format/

#include <ace/managers/ptplayer.h>
#include <ace/managers/log.h>
#include <ace/managers/system.h>
#include <ace/utils/custom.h>
#include <ace/utils/disk_file.h>
#include <hardware/intbits.h>
#include <hardware/dmabits.h>

//----------------------------------------------------------------------- CONFIG

// If set, uses VBL interrupt for processing playback, otherwise uses CIA timer.
// Buggy!
// #define PTPLAYER_USE_VBL

// If set, interrupts are as short as possible, rest is done
// in ptplayerProcess(). Buggy!
// #define PTPLAYER_DEFER_INTERRUPTS

// If set, uses audio interrupt handlers instead of polling intbits for checking
// if channel is idle. May be better in the long run for os-friendly use. Buggy!
// #define PTPLAYER_USE_AUDIO_INT_HANDLERS

// TODO: ENABLE_SAWRECT from ptplayer 6.1?
// TODO: MINIMAL from ptplayer?
// TODO: VBL-friendly changes from ptplayer 6.2

//---------------------------------------------------------------------- DEFINES

/**
 * @brief Minimum safe CIA timer ticks count after which Paula channel regs can
 * be set for next sample.
 *
 * A raster line has a DMA slot for each audio channel. Depending on the current
 * AUDxPER of the audio channel some of these DMA slots are not used.
 * For example: when playing a very high frequency the DMA might have to read
 * a new sample every line. But when playing a very low frequency there might be
 * 10 or more raster lines without DMA activity for this channel.
 *
 * The problem is that changes like DMA-on/off, or setting a new sample-pointer
 * in AUDxLC, are only recognized by Paula when the next sample data are read
 * from Chip-RAM.
 *
 * So we have to be prepared for the worst case, which means that
 * up to 11 raster lines may pass without DMA-activity (reading a new sample),
 * when playing the lowest note from the lowest Protracker octave.
 */
#define TIMERB_TICKS (576)

// Patterns - each has 64 rows, each row has 4 notes, each note has 4 bytes.
#define MOD_ROWS_IN_PATTERN 64
#define MOD_NOTES_PER_ROW 4
#define MOD_BYTES_PER_NOTE 4
// Length of single pattern.
#define MOD_PATTERN_LENGTH (MOD_ROWS_IN_PATTERN * MOD_NOTES_PER_ROW * MOD_BYTES_PER_NOTE)

// Size of period table.
#define MOD_PERIOD_TABLE_LENGTH 36

/**
 * @brief Delay in CIA-ticks, which guarantees that at least one Audio-DMA
 * took place, even with the lowest periods.
 * 496 should be the correct value. But there are some A1200 which
 * need at least 550.
 */
#define DMA_DELAY 576

#define SFX_PRIORITY_LOOPED 0xFF

//------------------------------------------------------------------------ TYPES

typedef struct AudChannel tChannelRegs;

/**
 * Each pattern line consists of following data for each channel.
 */
typedef struct _tModVoice {
	union {
		struct {
			UWORD uwNote; // [instrumentHi:4] [period:12]
			union {
				struct {
					UBYTE ubCmdHi; // [instrumentLo:4] [cmdNo:4]
					UBYTE ubCmdLo; // [cmdArg:8] - special effects data
				};
				UWORD uwCmd; // [instrumentLo:4] [cmdNo:4] [cmdArg:8]
			};
		};
		ULONG ulData; // All voice data for quick copy / comparison
	};
} tModVoice;

typedef struct _tChannelStatus {
	tModVoice sVoice;

	/**
	 * @brief Pointer to start of sample.
	 */
	UWORD *n_start;

	UWORD *n_loopstart;
	UWORD n_length;
	UWORD n_replen;
	UWORD uwPeriod;

	/**
	 * @brief Volume for channel (0..64)
	 */
	UWORD uwVolume;

	/**
	 * @brief Currently used period table - for arpeggio / fine-tune.
	 */
	const UWORD *pPeriodTable;

	UWORD uwDmaFlag; ///< Set with DMAF_AUDx
	UWORD n_noteoff; ///< TODO Later: convert it from byte offs to word offs (div by 2)
	UWORD n_toneportspeed;
	UWORD n_wantedperiod;
	UWORD n_pattpos;

	UWORD uwFunkSpeed;

	UBYTE *n_wavestart;
	UWORD n_reallength;
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	/**
	 * @brief Channel index.
	 *
	 * Original ptplayer name: n_index.
	 */
	UBYTE ubChannelIndex;

	volatile UBYTE *pDoneBit;
#endif

	/**
	 * @brief Pending sfx length. Set by player to 0 after registers are set
	 * to play it.
	 */
	UWORD uwSfxWordLength;

	UWORD *n_sfxptr;
	UWORD uwSfxPeriod;

	/**
	 * @brief Volume for sample (0..64)
	 */
	UWORD uwSfxVolume;

	/**
	 * @brief Set to 1 if sample has repeat offset/length which is other value
	 * than sample start / sample length - prevents from using channel for sfx
	 * after first sample play.
	 */
	UBYTE isLooped;

	/**
	 * @brief Set to 1 to indicate that finetune value is negative.
	 */
	UBYTE n_minusft;

	UBYTE n_vibratoamp;
	UBYTE n_vibratospd;
	UBYTE n_vibratopos;
	UBYTE n_vibratoctrl;
	UBYTE n_tremoloamp;
	UBYTE n_tremolospd;
	UBYTE n_tremolopos;
	UBYTE n_tremoloctrl;
	UBYTE n_gliss;
	UBYTE n_sampleoffset;
	BYTE n_loopcount;
	BYTE n_funkoffset;
	UBYTE n_retrigcount;

	/**
	 * Priority of currently played SFX, MOD samples use 0. Cleared after sfx
	 * has fully played back.
	 */
	volatile UBYTE ubSfxPriority;

	UBYTE n_freecnt;

	/**
	 * @brief Set to non-zero if channel can only be used for music playback, zero = sfx+music.
	 */
	UBYTE isOnlyForMusic;

	/**
	 * @brief If enabled for ptplayer playback, set to 0xFF, otherwise set to 0.
	 */
	UBYTE isEnabledForPlayer;
} tChannelStatus;

typedef void (*tVoidFn)(void);
typedef void (*tFx)(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
);

/**
 * @brief E Command callback.
 *
 * @param ubArg - E command parameter, set to 0..F.
 */
typedef void (*tEFn)(
	UBYTE ubArg, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
);

typedef void (*tPreFx)(
	UWORD uwCmd, UWORD uwCmdArg, UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
);

typedef union _tChannelDone {
	struct {
		UBYTE pChannels[4]; ///< Used for getting/setting each channel separately.
	};
	ULONG ulChannelMask; ///< Handy for query if any channel is active or clearing.
} tChannelDone;

//----------------------------------------------------------------- PRIVATE VARS

/**
 * @brief Period tables for each finetune value.
 * Each period table consists of periods for notes:
 * C-1, C#1, D-1, D#1, E-1, F-1, F#1, G-1, G#1, A-1, A#1, B-1,
 * C-2, C#2, D-2, D#2, E-2, F-2, F#2, G-2, G#2, A-2, A#2, B-2,
 * C-3, C#3, D-3, D#3, E-3, F-3, F#3, G-3, G#3, A-3, A#3, B-3
 */
static const UWORD mt_PeriodTables[][MOD_PERIOD_TABLE_LENGTH] = {
	{
		856, 808, 762, 720, 678, 640, 604, 570, 538, 508, 480, 453,
		428, 404, 381, 360, 339, 320, 302, 285, 269, 254, 240, 226,
		214, 202, 190, 180, 170, 160, 151, 143, 135, 127, 120, 113
	},
	{
		850, 802, 757, 715, 674, 637, 601, 567, 535, 505, 477, 450,
		425, 401, 379, 357, 337, 318, 300, 284, 268, 253, 239, 225,
		213, 201, 189, 179, 169, 159, 150, 142, 134, 126, 119, 113
	},
	{
		844, 796, 752, 709, 670, 632, 597, 563, 532, 502, 474, 447,
		422, 398, 376, 355, 335, 316, 298, 282, 266, 251, 237, 224,
		211, 199, 188, 177, 167, 158, 149, 141, 133, 125, 118, 112
	},
	{
		838, 791, 746, 704, 665, 628, 592, 559, 528, 498, 470, 444,
		419, 395, 373, 352, 332, 314, 296, 280, 264, 249, 235, 222,
		209, 198, 187, 176, 166, 157, 148, 140, 132, 125, 118, 111
	},
	{
		832, 785, 741, 699, 660, 623, 588, 555, 524, 495, 467, 441,
		416, 392, 370, 350, 330, 312, 294, 278, 262, 247, 233, 220,
		208, 196, 185, 175, 165, 156, 147, 139, 131, 124, 117, 110
	},
	{
		826, 779, 736, 694, 655, 619, 584, 551, 520, 491, 463, 437,
		413, 390, 368, 347, 328, 309, 292, 276, 260, 245, 232, 219,
		206, 195, 184, 174, 164, 155, 146, 138, 130, 123, 116, 109
	},
	{
		820, 774, 730, 689, 651, 614, 580, 547, 516, 487, 460, 434,
		410, 387, 365, 345, 325, 307, 290, 274, 258, 244, 230, 217,
		205, 193, 183, 172, 163, 154, 145, 137, 129, 122, 115, 109
	},
	{
		814, 768, 725, 684, 646, 610, 575, 543, 513, 484, 457, 431,
		407, 384, 363, 342, 323, 305, 288, 272, 256, 242, 228, 216,
		204, 192, 181, 171, 161, 152, 144, 136, 128, 121, 114, 108
	},
	{
		907, 856, 808, 762, 720, 678, 640, 604, 570, 538, 508, 480,
		453, 428, 404, 381, 360, 339, 320, 302, 285, 269, 254, 240,
		226, 214, 202, 190, 180, 170, 160, 151, 143, 135, 127, 120
	},
	{
		900, 850, 802, 757, 715, 675, 636, 601, 567, 535, 505, 477,
		450, 425, 401, 379, 357, 337, 318, 300, 284, 268, 253, 238,
		225, 212, 200, 189, 179, 169, 159, 150, 142, 134, 126, 119
	},
	{
		894, 844, 796, 752, 709, 670, 632, 597, 563, 532, 502, 474,
		447, 422, 398, 376, 355, 335, 316, 298, 282, 266, 251, 237,
		223, 211, 199, 188, 177, 167, 158, 149, 141, 133, 125, 118
	},
	{
		887, 838, 791, 746, 704, 665, 628, 592, 559, 528, 498, 470,
		444, 419, 395, 373, 352, 332, 314, 296, 280, 264, 249, 235,
		222, 209, 198, 187, 176, 166, 157, 148, 140, 132, 125, 118
	},
	{
		881, 832, 785, 741, 699, 660, 623, 588, 555, 524, 494, 467,
		441, 416, 392, 370, 350, 330, 312, 294, 278, 262, 247, 233,
		220, 208, 196, 185, 175, 165, 156, 147, 139, 131, 123, 117
	},
	{
		875, 826, 779, 736, 694, 655, 619, 584, 551, 520, 491, 463,
		437, 413, 390, 368, 347, 328, 309, 292, 276, 260, 245, 232,
		219, 206, 195, 184, 174, 164, 155, 146, 138, 130, 123, 116
	},
	{
		868, 820, 774, 730, 689, 651, 614, 580, 547, 516, 487, 460,
		434, 410, 387, 365, 345, 325, 307, 290, 274, 258, 244, 230,
		217, 205, 193, 183, 172, 163, 154, 145, 137, 129, 122, 115
	},
	{
		862, 814, 768, 725, 684, 646, 610, 575, 543, 513, 484, 457,
		431, 407, 384, 363, 342, 323, 305, 288, 272, 256, 242, 228,
		216, 203, 192, 181, 171, 161, 152, 144, 136, 128, 121, 114
	}
};

static const UBYTE MasterVolTab[][65] = {
	{
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0
	}, {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		1
	}, {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		2
	}, {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,
		2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
		3
	}, {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
		3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
		4
	}, {
		0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
		1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
		2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,
		3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,
		5
	}, {
		0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
		1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
		3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,
		4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,
		6
	}, {
		0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
		1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,
		3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,
		5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
		7
	}, {
		0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
		2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,
		4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,
		6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,
		8
	}, {
		0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,
		2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,
		4,4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,
		6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,
		9
	}, {
		0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,
		2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4,
		5,5,5,5,5,5,5,6,6,6,6,6,6,7,7,7,
		7,7,7,7,8,8,8,8,8,8,9,9,9,9,9,9,
		10
	}, {
		0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,
		2,2,3,3,3,3,3,3,4,4,4,4,4,4,5,5,
		5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,8,
		8,8,8,8,8,9,9,9,9,9,9,10,10,10,10,10,
		11
	}, {
		0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,
		3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,
		6,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,
		9,9,9,9,9,9,10,10,10,10,10,11,11,11,11,11,
		12
	}, {
		0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,
		3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,
		6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,
		9,9,10,10,10,10,10,11,11,11,11,11,12,12,12,12,
		13
	}, {
		0,0,0,0,0,1,1,1,1,1,2,2,2,2,3,3,
		3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,
		7,7,7,7,7,8,8,8,8,8,9,9,9,9,10,10,
		10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,
		14
	}, {
		0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,
		3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,
		7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,
		11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,
		15
	}, {
		0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,
		4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,
		8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,
		12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,
		16
	}, {
		0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,
		4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,
		8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,
		12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,
		17
	}, {
		0,0,0,0,1,1,1,1,2,2,2,3,3,3,3,4,
		4,4,5,5,5,5,6,6,6,7,7,7,7,8,8,8,
		9,9,9,9,10,10,10,10,11,11,11,12,12,12,12,13,
		13,13,14,14,14,14,15,15,15,16,16,16,16,17,17,17,
		18
	}, {
		0,0,0,0,1,1,1,2,2,2,2,3,3,3,4,4,
		4,5,5,5,5,6,6,6,7,7,7,8,8,8,8,9,
		9,9,10,10,10,10,11,11,11,12,12,12,13,13,13,13,
		14,14,14,15,15,15,16,16,16,16,17,17,17,18,18,18,
		19
	}, {
		0,0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,
		5,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,
		10,10,10,10,11,11,11,12,12,12,13,13,13,14,14,14,
		15,15,15,15,16,16,16,17,17,17,18,18,18,19,19,19,
		20
	}, {
		0,0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,
		5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,
		10,10,11,11,11,12,12,12,13,13,13,14,14,14,15,15,
		15,16,16,16,17,17,17,18,18,18,19,19,19,20,20,20,
		21
	}, {
		0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,
		5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,
		11,11,11,12,12,12,13,13,13,14,14,14,15,15,15,16,
		16,16,17,17,17,18,18,18,19,19,19,20,20,20,21,21,
		22
	}, {
		0,0,0,1,1,1,2,2,2,3,3,3,4,4,5,5,
		5,6,6,6,7,7,7,8,8,8,9,9,10,10,10,11,
		11,11,12,12,12,13,13,14,14,14,15,15,15,16,16,16,
		17,17,17,18,18,19,19,19,20,20,20,21,21,21,22,22,
		23
	}, {
		0,0,0,1,1,1,2,2,3,3,3,4,4,4,5,5,
		6,6,6,7,7,7,8,8,9,9,9,10,10,10,11,11,
		12,12,12,13,13,13,14,14,15,15,15,16,16,16,17,17,
		18,18,18,19,19,19,20,20,21,21,21,22,22,22,23,23,
		24
	}, {
		0,0,0,1,1,1,2,2,3,3,3,4,4,5,5,5,
		6,6,7,7,7,8,8,8,9,9,10,10,10,11,11,12,
		12,12,13,13,14,14,14,15,15,16,16,16,17,17,17,18,
		18,19,19,19,20,20,21,21,21,22,22,23,23,23,24,24,
		25
	}, {
		0,0,0,1,1,2,2,2,3,3,4,4,4,5,5,6,
		6,6,7,7,8,8,8,9,9,10,10,10,11,11,12,12,
		13,13,13,14,14,15,15,15,16,16,17,17,17,18,18,19,
		19,19,20,20,21,21,21,22,22,23,23,23,24,24,25,25,
		26
	}, {
		0,0,0,1,1,2,2,2,3,3,4,4,5,5,5,6,
		6,7,7,8,8,8,9,9,10,10,10,11,11,12,12,13,
		13,13,14,14,15,15,16,16,16,17,17,18,18,18,19,19,
		20,20,21,21,21,22,22,23,23,24,24,24,25,25,26,26,
		27
	}, {
		0,0,0,1,1,2,2,3,3,3,4,4,5,5,6,6,
		7,7,7,8,8,9,9,10,10,10,11,11,12,12,13,13,
		14,14,14,15,15,16,16,17,17,17,18,18,19,19,20,20,
		21,21,21,22,22,23,23,24,24,24,25,25,26,26,27,27,
		28
	}, {
		0,0,0,1,1,2,2,3,3,4,4,4,5,5,6,6,
		7,7,8,8,9,9,9,10,10,11,11,12,12,13,13,14,
		14,14,15,15,16,16,17,17,18,18,19,19,19,20,20,21,
		21,22,22,23,23,24,24,24,25,25,26,26,27,27,28,28,
		29
	}, {
		0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,
		7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,
		15,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,
		22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,
		30
	}, {
		0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,
		7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,
		15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,
		23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,
		31
	}, {
		0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,
		8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,
		16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,
		24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,
		32
	}, {
		0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,
		8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,
		16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,
		24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,
		33
	}, {
		0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,
		8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,
		17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,
		25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,
		34
	}, {
		0,0,1,1,2,2,3,3,4,4,5,6,6,7,7,8,
		8,9,9,10,10,11,12,12,13,13,14,14,15,15,16,16,
		17,18,18,19,19,20,20,21,21,22,22,23,24,24,25,25,
		26,26,27,27,28,28,29,30,30,31,31,32,32,33,33,34,
		35
	}, {
		0,0,1,1,2,2,3,3,4,5,5,6,6,7,7,8,
		9,9,10,10,11,11,12,12,13,14,14,15,15,16,16,17,
		18,18,19,19,20,20,21,21,22,23,23,24,24,25,25,26,
		27,27,28,28,29,29,30,30,31,32,32,33,33,34,34,35,
		36
	}, {
		0,0,1,1,2,2,3,4,4,5,5,6,6,7,8,8,
		9,9,10,10,11,12,12,13,13,14,15,15,16,16,17,17,
		18,19,19,20,20,21,21,22,23,23,24,24,25,26,26,27,
		27,28,28,29,30,30,31,31,32,32,33,34,34,35,35,36,
		37
	}, {
		0,0,1,1,2,2,3,4,4,5,5,6,7,7,8,8,
		9,10,10,11,11,12,13,13,14,14,15,16,16,17,17,18,
		19,19,20,20,21,21,22,23,23,24,24,25,26,26,27,27,
		28,29,29,30,30,31,32,32,33,33,34,35,35,36,36,37,
		38
	}, {
		0,0,1,1,2,3,3,4,4,5,6,6,7,7,8,9,
		9,10,10,11,12,12,13,14,14,15,15,16,17,17,18,18,
		19,20,20,21,21,22,23,23,24,24,25,26,26,27,28,28,
		29,29,30,31,31,32,32,33,34,34,35,35,36,37,37,38,
		39
	}, {
		0,0,1,1,2,3,3,4,5,5,6,6,7,8,8,9,
		10,10,11,11,12,13,13,14,15,15,16,16,17,18,18,19,
		20,20,21,21,22,23,23,24,25,25,26,26,27,28,28,29,
		30,30,31,31,32,33,33,34,35,35,36,36,37,38,38,39,
		40
	}, {
		0,0,1,1,2,3,3,4,5,5,6,7,7,8,8,9,
		10,10,11,12,12,13,14,14,15,16,16,17,17,18,19,19,
		20,21,21,22,23,23,24,24,25,26,26,27,28,28,29,30,
		30,31,32,32,33,33,34,35,35,36,37,37,38,39,39,40,
		41
	}, {
		0,0,1,1,2,3,3,4,5,5,6,7,7,8,9,9,
		10,11,11,12,13,13,14,15,15,16,17,17,18,19,19,20,
		21,21,22,22,23,24,24,25,26,26,27,28,28,29,30,30,
		31,32,32,33,34,34,35,36,36,37,38,38,39,40,40,41,
		42
	}, {
		0,0,1,2,2,3,4,4,5,6,6,7,8,8,9,10,
		10,11,12,12,13,14,14,15,16,16,17,18,18,19,20,20,
		21,22,22,23,24,24,25,26,26,27,28,28,29,30,30,31,
		32,32,33,34,34,35,36,36,37,38,38,39,40,40,41,42,
		43
	}, {
		0,0,1,2,2,3,4,4,5,6,6,7,8,8,9,10,
		11,11,12,13,13,14,15,15,16,17,17,18,19,19,20,21,
		22,22,23,24,24,25,26,26,27,28,28,29,30,30,31,32,
		33,33,34,35,35,36,37,37,38,39,39,40,41,41,42,43,
		44
	}, {
		0,0,1,2,2,3,4,4,5,6,7,7,8,9,9,10,
		11,11,12,13,14,14,15,16,16,17,18,18,19,20,21,21,
		22,23,23,24,25,26,26,27,28,28,29,30,30,31,32,33,
		33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,
		45
	}, {
		0,0,1,2,2,3,4,5,5,6,7,7,8,9,10,10,
		11,12,12,13,14,15,15,16,17,17,18,19,20,20,21,22,
		23,23,24,25,25,26,27,28,28,29,30,30,31,32,33,33,
		34,35,35,36,37,38,38,39,40,40,41,42,43,43,44,45,
		46
	}, {
		0,0,1,2,2,3,4,5,5,6,7,8,8,9,10,11,
		11,12,13,13,14,15,16,16,17,18,19,19,20,21,22,22,
		23,24,24,25,26,27,27,28,29,30,30,31,32,33,33,34,
		35,35,36,37,38,38,39,40,41,41,42,43,44,44,45,46,
		47
	}, {
		0,0,1,2,3,3,4,5,6,6,7,8,9,9,10,11,
		12,12,13,14,15,15,16,17,18,18,19,20,21,21,22,23,
		24,24,25,26,27,27,28,29,30,30,31,32,33,33,34,35,
		36,36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,
		48
	}, {
		0,0,1,2,3,3,4,5,6,6,7,8,9,9,10,11,
		12,13,13,14,15,16,16,17,18,19,19,20,21,22,22,23,
		24,25,26,26,27,28,29,29,30,31,32,32,33,34,35,35,
		36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,48,
		49
	}, {
		0,0,1,2,3,3,4,5,6,7,7,8,9,10,10,11,
		12,13,14,14,15,16,17,17,18,19,20,21,21,22,23,24,
		25,25,26,27,28,28,29,30,31,32,32,33,34,35,35,36,
		37,38,39,39,40,41,42,42,43,44,45,46,46,47,48,49,
		50
	}, {
		0,0,1,2,3,3,4,5,6,7,7,8,9,10,11,11,
		12,13,14,15,15,16,17,18,19,19,20,21,22,23,23,24,
		25,26,27,27,28,29,30,31,31,32,33,34,35,35,36,37,
		38,39,39,40,41,42,43,43,44,45,46,47,47,48,49,50,
		51
	}, {
		0,0,1,2,3,4,4,5,6,7,8,8,9,10,11,12,
		13,13,14,15,16,17,17,18,19,20,21,21,22,23,24,25,
		26,26,27,28,29,30,30,31,32,33,34,34,35,36,37,38,
		39,39,40,41,42,43,43,44,45,46,47,47,48,49,50,51,
		52
	}, {
		0,0,1,2,3,4,4,5,6,7,8,9,9,10,11,12,
		13,14,14,15,16,17,18,19,19,20,21,22,23,24,24,25,
		26,27,28,28,29,30,31,32,33,33,34,35,36,37,38,38,
		39,40,41,42,43,43,44,45,46,47,48,48,49,50,51,52,
		53
	}, {
		0,0,1,2,3,4,5,5,6,7,8,9,10,10,11,12,
		13,14,15,16,16,17,18,19,20,21,21,22,23,24,25,26,
		27,27,28,29,30,31,32,32,33,34,35,36,37,37,38,39,
		40,41,42,43,43,44,45,46,47,48,48,49,50,51,52,53,
		54
	}, {
		0,0,1,2,3,4,5,6,6,7,8,9,10,11,12,12,
		13,14,15,16,17,18,18,19,20,21,22,23,24,24,25,26,
		27,28,29,30,30,31,32,33,34,35,36,36,37,38,39,40,
		41,42,42,43,44,45,46,47,48,48,49,50,51,52,53,54,
		55
	}, {
		0,0,1,2,3,4,5,6,7,7,8,9,10,11,12,13,
		14,14,15,16,17,18,19,20,21,21,22,23,24,25,26,27,
		28,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,
		42,42,43,44,45,46,47,48,49,49,50,51,52,53,54,55,
		56
	}, {
		0,0,1,2,3,4,5,6,7,8,8,9,10,11,12,13,
		14,15,16,16,17,18,19,20,21,22,23,24,24,25,26,27,
		28,29,30,31,32,32,33,34,35,36,37,38,39,40,40,41,
		42,43,44,45,46,47,48,48,49,50,51,52,53,54,55,56,
		57
	}, {
		0,0,1,2,3,4,5,6,7,8,9,9,10,11,12,13,
		14,15,16,17,18,19,19,20,21,22,23,24,25,26,27,28,
		29,29,30,31,32,33,34,35,36,37,38,38,39,40,41,42,
		43,44,45,46,47,48,48,49,50,51,52,53,54,55,56,57,
		58
	}, {
		0,0,1,2,3,4,5,6,7,8,9,10,11,11,12,13,
		14,15,16,17,18,19,20,21,22,23,23,24,25,26,27,28,
		29,30,31,32,33,34,35,35,36,37,38,39,40,41,42,43,
		44,45,46,47,47,48,49,50,51,52,53,54,55,56,57,58,
		59
	}, {
		0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
		15,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
		30,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,
		45,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
		60
	}, {
		0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
		15,16,17,18,19,20,20,21,22,23,24,25,26,27,28,29,
		30,31,32,33,34,35,36,37,38,39,40,40,41,42,43,44,
		45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,
		61
	}, {
		0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
		15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
		31,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,
		46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,
		62
	}, {
		0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
		15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
		31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,
		47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,
		63
	}, {
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
		32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
		48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
		64
	}
};

static const UBYTE mt_FunkTable[] = {
	0, 5, 6, 7, 8, 10, 11, 13, 16, 19, 22, 26, 32, 43, 64, 128
};

static const BYTE mt_VibratoSineTable[] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
	0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,
	0,0,0,1,1,1,2,2,2,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,2,2,2,1,1,1,0,0,
	0,0,0,-1,-1,-1,-2,-2,-2,-3,-3,-3,-3,-3,-3,-3,
	-3,-3,-3,-3,-3,-3,-3,-3,-2,-2,-2,-1,-1,-1,0,0,
	0,0,1,1,2,2,3,3,4,4,4,5,5,5,5,5,
	5,5,5,5,5,5,4,4,4,3,3,2,2,1,1,0,
	0,0,-1,-1,-2,-2,-3,-3,-4,-4,-4,-5,-5,-5,-5,-5,
	-5,-5,-5,-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-1,-1,0,
	0,0,1,2,3,3,4,5,5,6,6,7,7,7,7,7,
	7,7,7,7,7,7,6,6,5,5,4,3,3,2,1,0,
	0,0,-1,-2,-3,-3,-4,-5,-5,-6,-6,-7,-7,-7,-7,-7,
	-7,-7,-7,-7,-7,-7,-6,-6,-5,-5,-4,-3,-3,-2,-1,0,
	0,0,1,2,3,4,5,6,7,7,8,8,9,9,9,9,
	9,9,9,9,9,8,8,7,7,6,5,4,3,2,1,0,
	0,0,-1,-2,-3,-4,-5,-6,-7,-7,-8,-8,-9,-9,-9,-9,
	-9,-9,-9,-9,-9,-8,-8,-7,-7,-6,-5,-4,-3,-2,-1,0,
	0,1,2,3,4,5,6,7,8,9,9,10,11,11,11,11,
	11,11,11,11,11,10,9,9,8,7,6,5,4,3,2,1,
	0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-9,-10,-11,-11,-11,-11,
	-11,-11,-11,-11,-11,-10,-9,-9,-8,-7,-6,-5,-4,-3,-2,-1,
	0,1,2,4,5,6,7,8,9,10,11,12,12,13,13,13,
	13,13,13,13,12,12,11,10,9,8,7,6,5,4,2,1,
	0,-1,-2,-4,-5,-6,-7,-8,-9,-10,-11,-12,-12,-13,-13,-13,
	-13,-13,-13,-13,-12,-12,-11,-10,-9,-8,-7,-6,-5,-4,-2,-1,
	0,1,3,4,6,7,8,10,11,12,13,14,14,15,15,15,
	15,15,15,15,14,14,13,12,11,10,8,7,6,4,3,1,
	0,-1,-3,-4,-6,-7,-8,-10,-11,-12,-13,-14,-14,-15,-15,-15,
	-15,-15,-15,-15,-14,-14,-13,-12,-11,-10,-8,-7,-6,-4,-3,-1,
	0,1,3,5,6,8,9,11,12,13,14,15,16,17,17,17,
	17,17,17,17,16,15,14,13,12,11,9,8,6,5,3,1,
	0,-1,-3,-5,-6,-8,-9,-11,-12,-13,-14,-15,-16,-17,-17,-17,
	-17,-17,-17,-17,-16,-15,-14,-13,-12,-11,-9,-8,-6,-5,-3,-1,
	0,1,3,5,7,9,11,12,14,15,16,17,18,19,19,19,
	19,19,19,19,18,17,16,15,14,12,11,9,7,5,3,1,
	0,-1,-3,-5,-7,-9,-11,-12,-14,-15,-16,-17,-18,-19,-19,-19,
	-19,-19,-19,-19,-18,-17,-16,-15,-14,-12,-11,-9,-7,-5,-3,-1,
	0,2,4,6,8,10,12,13,15,16,18,19,20,20,21,21,
	21,21,21,20,20,19,18,16,15,13,12,10,8,6,4,2,
	0,-2,-4,-6,-8,-10,-12,-13,-15,-16,-18,-19,-20,-20,-21,-21,
	-21,-21,-21,-20,-20,-19,-18,-16,-15,-13,-12,-10,-8,-6,-4,-2,
	0,2,4,6,9,11,13,15,16,18,19,21,22,22,23,23,
	23,23,23,22,22,21,19,18,16,15,13,11,9,6,4,2,
	0,-2,-4,-6,-9,-11,-13,-15,-16,-18,-19,-21,-22,-22,-23,-23,
	-23,-23,-23,-22,-22,-21,-19,-18,-16,-15,-13,-11,-9,-6,-4,-2,
	0,2,4,7,9,12,14,16,18,20,21,22,23,24,25,25,
	25,25,25,24,23,22,21,20,18,16,14,12,9,7,4,2,
	0,-2,-4,-7,-9,-12,-14,-16,-18,-20,-21,-22,-23,-24,-25,-25,
	-25,-25,-25,-24,-23,-22,-21,-20,-18,-16,-14,-12,-9,-7,-4,-2,
	0,2,5,8,10,13,15,17,19,21,23,24,25,26,27,27,
	27,27,27,26,25,24,23,21,19,17,15,13,10,8,5,2,
	0,-2,-5,-8,-10,-13,-15,-17,-19,-21,-23,-24,-25,-26,-27,-27,
	-27,-27,-27,-26,-25,-24,-23,-21,-19,-17,-15,-13,-10,-8,-5,-2,
	0,2,5,8,11,14,16,18,21,23,24,26,27,28,29,29,
	29,29,29,28,27,26,24,23,21,18,16,14,11,8,5,2,
	0,-2,-5,-8,-11,-14,-16,-18,-21,-23,-24,-26,-27,-28,-29,-29,
	-29,-29,-29,-28,-27,-26,-24,-23,-21,-18,-16,-14,-11,-8,-5,-2
};

static const BYTE mt_VibratoSawTable[] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
	2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,
	-3,-3,-3,-3,-3,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-2,
	-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,
	3,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,
	-5,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-3,-3,
	-2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,
	0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,
	4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,
	-7,-7,-7,-7,-6,-6,-6,-6,-5,-5,-5,-5,-4,-4,-4,-4,
	-3,-3,-3,-3,-2,-2,-2,-2,-1,-1,-1,-1,0,0,0,0,
	0,0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,
	5,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,
	-9,-9,-9,-9,-8,-8,-8,-7,-7,-7,-6,-6,-6,-5,-5,-5,
	-4,-4,-4,-4,-3,-3,-3,-2,-2,-2,-1,-1,-1,0,0,0,
	0,0,0,1,1,1,2,2,3,3,3,4,4,4,5,5,
	6,6,6,7,7,7,8,8,9,9,9,10,10,10,11,11,
	-11,-11,-11,-10,-10,-10,-9,-9,-8,-8,-8,-7,-7,-7,-6,-6,
	-5,-5,-5,-4,-4,-4,-3,-3,-2,-2,-2,-1,-1,-1,0,0,
	0,0,0,1,1,2,2,3,3,3,4,4,5,5,6,6,
	7,7,7,8,8,9,9,10,10,10,11,11,12,12,13,13,
	-13,-13,-13,-12,-12,-11,-11,-10,-10,-10,-9,-9,-8,-8,-7,-7,
	-6,-6,-6,-5,-5,-4,-4,-3,-3,-3,-2,-2,-1,-1,0,0,
	0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,
	8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,
	-15,-15,-14,-14,-13,-13,-12,-12,-11,-11,-10,-10,-9,-9,-8,-8,
	-7,-7,-6,-6,-5,-5,-4,-4,-3,-3,-2,-2,-1,-1,0,0,
	0,0,1,1,2,2,3,3,4,5,5,6,6,7,7,8,
	9,9,10,10,11,11,12,12,13,14,14,15,15,16,16,17,
	-17,-17,-16,-16,-15,-15,-14,-13,-13,-12,-12,-11,-11,-10,-10,-9,
	-8,-8,-7,-7,-6,-6,-5,-4,-4,-3,-3,-2,-2,-1,-1,0,
	0,0,1,1,2,3,3,4,5,5,6,6,7,8,8,9,
	10,10,11,11,12,13,13,14,15,15,16,16,17,18,18,19,
	-19,-19,-18,-18,-17,-16,-16,-15,-14,-14,-13,-13,-12,-11,-11,-10,
	-9,-9,-8,-8,-7,-6,-6,-5,-4,-4,-3,-3,-2,-1,-1,0,
	0,0,1,2,2,3,4,4,5,6,6,7,8,8,9,10,
	11,11,12,13,13,14,15,15,16,17,17,18,19,19,20,21,
	-21,-21,-20,-19,-19,-18,-17,-17,-16,-15,-15,-14,-13,-12,-12,-11,
	-10,-10,-9,-8,-8,-7,-6,-6,-5,-4,-4,-3,-2,-1,-1,0,
	0,0,1,2,3,3,4,5,6,6,7,8,9,9,10,11,
	12,12,13,14,15,15,16,17,18,18,19,20,21,21,22,23,
	-23,-23,-22,-21,-20,-20,-19,-18,-17,-17,-16,-15,-14,-14,-13,-12,
	-11,-11,-10,-9,-8,-8,-7,-6,-5,-5,-4,-3,-2,-2,-1,0,
	0,0,1,2,3,4,4,5,6,7,8,8,9,10,11,12,
	13,13,14,15,16,17,17,18,19,20,21,21,22,23,24,25,
	-25,-25,-24,-23,-22,-21,-21,-20,-19,-18,-17,-16,-16,-15,-14,-13,
	-12,-12,-11,-10,-9,-8,-8,-7,-6,-5,-4,-3,-3,-2,-1,0,
	0,0,1,2,3,4,5,6,7,7,8,9,10,11,12,13,
	14,14,15,16,17,18,19,20,21,21,22,23,24,25,26,27,
	-27,-27,-26,-25,-24,-23,-22,-21,-20,-20,-19,-18,-17,-16,-15,-14,
	-13,-13,-12,-11,-10,-9,-8,-7,-6,-6,-5,-4,-3,-2,-1,0,
	0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
	15,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
	-29,-28,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,
	-14,-13,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0
};

static const BYTE mt_VibratoRectTable[] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,
	-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,
	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
	-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,
	-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,
	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
	-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,
	-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,-7,
	9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
	9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
	-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,
	-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,
	11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
	-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,
	-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,-11,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,
	-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,-13,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,
	-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,
	-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,-17,
	19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
	19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
	-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,
	-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,
	21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
	21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
	-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,
	-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,-21,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,
	-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,-23,
	25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
	25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
	-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,
	-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,-25,
	27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
	27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
	-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,
	-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,-27,
	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
	-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,
	-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29,-29
};

static const tFx fx_tab[16];
static const tFx morefx_tab[16];
static const tFx blmorefx_tab[16];
static const tEFn ecmd_tab[16];
static const tEFn blecmd_tab[16];
static const tPreFx prefx_tab[16];

#if defined(PTPLAYER_DEFER_INTERRUPTS)
static volatile UBYTE s_isPendingPlay, s_isPendingSetRep, s_isPendingDmaOn;
#endif
static UBYTE s_isRepeat;
static tPtplayerCbSongEnd s_cbSongEnd;
static UBYTE s_isPal;

#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
/**
 * @brief Indicators for each channel being free to use. Channel is set to 1 if
 * it has done playback.
 */
static volatile tChannelDone s_uChannelDone;

/**
 * @brief Set to 1 for channel after it has been instructed to play back 1-word
 * null loop. Set to 0 on audio interrupt after finishing null loop playback and
 * disabling channel DMA to keep it from retriggering audio interrupt.
 */
static volatile UBYTE s_pAudioChannelPendingDisable[4];
#endif

static void blocked_e_cmds(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
);

static void set_finetune(
	UWORD uwCmd, UWORD uwCmdArg, UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
);

static volatile UBYTE mt_MusicChannels = 0;
static volatile UBYTE mt_E8Trigger = 0;
static volatile UBYTE mt_Enable = 0;

/**
 * @brief Used to determine what Timer B interrupt should do next.
 *
 * Original ptplayer variable name: TB_toggle.
 */
static volatile UBYTE s_isNextTimerBSetRep;

static tChannelStatus mt_chan[4];
static UWORD *mt_SampleStarts[PTPLAYER_MOD_SAMPLE_COUNT]; ///< Start address of each sample
static tPtplayerMod *mt_mod; ///< Currently played MOD.
static ULONG mt_timerval; ///< Base interrupt frequency of CIA-B timer A used to advance the song. Equals 125*50Hz.
static const UBYTE * mt_MasterVolTab;
static UWORD mt_PatternPos;
static UWORD mt_PBreakPos; ///< Pattern break pos
static UBYTE mt_PosJumpFlag;
static UBYTE mt_PBreakFlag;
static UBYTE mt_Speed; ///< Number of times the main loop gets called per note step.
static UBYTE mt_Counter; ///< Number of main loop iterations in current note step so far.
static UBYTE mt_SongPos; ///< Position in arrangement.
static UBYTE mt_PattDelTime;
static UBYTE mt_PattDelTime2;
static UBYTE mt_SilCntValid;

/**
 * Each player loop generates this from scratch.
 *
 * Set with DMAF_AUD# when sfx is to be played, by retrigger/period cmds.
 *
 * Used in following DMA enable interrupt or in same loop pass to see
 * if channels are blocked. Also clears interrupt bits for set up channels
 * to indicate that they are busy.
 */
static UWORD mt_dmaon = 0;

static tPtplayerMod *s_pModCurr;

static void clearAudioDone(void) {
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	// When channel is idle, original ptplayer loops playback of the first word
	// and allows Paula to keep the intbit being set, so clearing here intreq
	// for all channels didn't permanently affected idle channel bits.
	// int-handler version disables channel's DMA when sfx played back to prevent
	// interrupt spamming, so they can't maintain the 'done' intbit.
	s_uChannelDone.ulChannelMask = 0;
#else
	// for some reason I've had the following code here - why?
	// g_pCustom->intreq = INTF_AUD0 | INTF_AUD1 | INTF_AUD2 | INTF_AUD3;
	// KaiN's note: Audio dmaBits = 0b0001..0b1000, intBits = dmaBits << 7
	g_pCustom->intreq = (mt_dmaon << 7) | INTF_EXTER;
#endif
}

static void setAudioDone(UNUSED_ARG tChannelStatus *pChannelData) {
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	pChannelData->pDoneBit = 1;
#endif
}

static UBYTE isChannelDone(tChannelStatus *pChannelData) {
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	return *pChannelData->pDoneBit;
#else
	if (pChannelData->isLooped) {
		// Looping channels are not done
		return 0;
	}

	// This doesn't work when nothing has yet played - check dmaconr for that
	// KaiN's note: Audio dmaBits = 0b0001..0b1000, intBits = dmaBits << 7
	UWORD uwIntReqr = g_pCustom->intreqr;

	// `!= 0` must be here, because downcasting to UBYTE may discard higher intbit
	// and channel will be busy indefinitely!
	UBYTE isBusy = (uwIntReqr & (pChannelData->uwDmaFlag << 7)) != 0;
	return isBusy;
#endif
}

static void printVoices(UNUSED_ARG const tModVoice *pVoices) {
#if defined(ACE_DEBUG_PTPLAYER)
	typedef struct _tPeriodNote {
		UWORD uwPeriod;
		const char *szNote;
	} tPeriodNote;

	// Taken from https://www.fileformat.info/format/mod/corion.htm, table 5
	static const tPeriodNote pPeriod2Note[] = {
		{1712, "C-0"}, {1616, "C#0"}, {1524, "D-0"}, {1440, "D#0"},
		{1356, "E-0"}, {1280, "F-0"}, {1208, "F#0"}, {1140, "G-0"},
		{1076, "G#0"}, {1016, "A-0"}, { 960, "A#0"}, { 906, "B-0"},

		{ 856, "C-1"}, { 808, "C#1"}, { 762, "D-1"}, { 720, "D#1"},
		{ 678, "E-1"}, { 640, "F-1"}, { 604, "F#1"}, { 570, "G-1"},
		{ 538, "G#1"}, { 508, "A-1"}, { 480, "A#1"}, { 453, "B-1"},

		{ 428, "C-2"}, { 404, "C#2"}, { 381, "D-2"}, { 360, "D#2"},
		{ 339, "E-2"}, { 320, "F-2"}, { 302, "F#2"}, { 285, "G-2"},
		{ 269, "G#2"}, { 254, "A-2"}, { 240, "A#2"}, { 226, "B-2"},

		{ 214, "C-3"}, { 202, "C#3"}, { 190, "D-3"}, { 180, "D#3"},
		{ 170, "E-3"}, { 160, "F-3"}, { 151, "F#3"}, { 143, "G-3"},
		{ 135, "G#3"}, { 127, "A-3"}, { 120, "A#3"}, { 113, "B-3I"},

		{ 107, "C-4"}, { 101, "C#4"}, {  95, "D-4"}, {  90, "D#4"},
		{  85, "E-4"}, {  80, "F-4"}, {  75, "F#4"}, {  71, "G-4"},
		{  67, "G#4"}, {  63, "A-4"}, {  60, "A#4"}, {  56, "B-4"},
		{   0, "   "}
	};

	// logWrite(
	// 	"Row (cmd.note): %04X.%04X, %04X.%04X, %04X.%04X, %04X.%04X\n",
	// 	pVoices[0].uwCmd, pVoices[0].uwNote,
	// 	pVoices[1].uwCmd, pVoices[1].uwNote,
	// 	pVoices[2].uwCmd, pVoices[2].uwNote,
	// 	pVoices[3].uwCmd, pVoices[3].uwNote
	// );

	const char *pNotes[MOD_NOTES_PER_ROW];
	UBYTE pInstruments[MOD_NOTES_PER_ROW], pCmdIdx[MOD_NOTES_PER_ROW], pCmdArg[MOD_NOTES_PER_ROW];
	for(UBYTE ubVoice = 0; ubVoice < MOD_NOTES_PER_ROW; ++ubVoice) {
		const tModVoice *pVoice = &pVoices[ubVoice];
		UWORD uwPeriod = pVoice->uwNote & 0xFFF;
		pInstruments[ubVoice] = (pVoice->uwNote >> 8) | (pVoice->uwCmd >> 12);
		pCmdIdx[ubVoice] = (pVoice->uwCmd >> 8) & 0xF;
		pCmdArg[ubVoice] = pVoice->uwCmd & 0xFF;

		// Decode period -> note
		const char *szNote = "???";
		for(UBYTE i = 0; i < 61; ++i) {
			if(pPeriod2Note[i].uwPeriod == uwPeriod) {
				szNote = pPeriod2Note[i].szNote;
				break;
			}
		}
		pNotes[ubVoice] = szNote;
	}
	logWrite(
		"T %5lu note.instr.cmd.arg %s.%02hhX.%hhX.%02hhX  %s.%02hhX.%hhX.%02hhX  %s.%02hhX.%hhX.%02hhX  %s.%02hhX.%hhX.%02hhX\n",
		timerGet(),
		pNotes[0], pInstruments[0], pCmdIdx[0], pCmdArg[0],
		pNotes[1], pInstruments[1], pCmdIdx[1], pCmdArg[1],
		pNotes[2], pInstruments[2], pCmdIdx[2], pCmdArg[2],
		pNotes[3], pInstruments[3], pCmdIdx[3], pCmdArg[3]
	);
#endif
}

static inline UBYTE findPeriod(const UWORD *pPeriods, UWORD uwNote) {
	// Find nearest period for a note value
	for(UBYTE ubPeriodPos = 0; ubPeriodPos < MOD_PERIOD_TABLE_LENGTH - 1; ++ubPeriodPos) {
		if (uwNote >= pPeriods[ubPeriodPos]) {
			return ubPeriodPos;
		}
	}

	return MOD_PERIOD_TABLE_LENGTH - 1;
}

static void ptSongStep(void) {
	mt_PatternPos = mt_PBreakPos;
	mt_PBreakPos = 0;
	mt_PosJumpFlag = 0;

	// Next position in song
	UBYTE ubNextPos = (mt_SongPos + 1) & 0x7F;

	// End of song reached?
	if(ubNextPos >= mt_mod->ubArrangementLength) {
		ubNextPos = 0;
		if(!s_isRepeat) {
			ptplayerEnableMusic(0);
		}
		if(s_cbSongEnd) {
			s_cbSongEnd();
		}
	}
	mt_SongPos = ubNextPos;
	// Should be a check of mt_PosJumpFlag here, but unlikely that something will
	// set it in the meantime
}

static void startSfx(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
#if defined(ACE_DEBUG_PTPLAYER)
	logWrite("startsfx: %p:%hu\n", pChannelData->n_sfxptr, pChannelData->uwSfxWordLength);
#endif
	// play new sound effect on this channel
	systemSetDmaMask(pChannelData->uwDmaFlag, 0);
	UWORD uwRepeatLength;
	volatile UWORD *pSfxData = pChannelReg->ac_ptr = pChannelData->n_sfxptr;
	if(pChannelData->ubSfxPriority == SFX_PRIORITY_LOOPED) {
		pChannelData->isLooped = 1;

		// Skip first word which is used for idling
		++pSfxData;
		uwRepeatLength = pChannelData->uwSfxWordLength - 1;
		pChannelReg->ac_ptr = pSfxData;
		pChannelReg->ac_len = uwRepeatLength;
	}
	else {
		pChannelData->isLooped = 0;
		uwRepeatLength = 1;
		pChannelReg->ac_ptr = pSfxData;
		pChannelReg->ac_len = pChannelData->uwSfxWordLength;
	}
	pChannelReg->ac_per = pChannelData->uwSfxPeriod;
	pChannelReg->ac_vol = pChannelData->uwSfxVolume;

	// Save repeat and period for TimerB interrupt.
	// After the sample has fully played back and there is no repeat,
	// the channel's pointer will be set to first word of sample and play back
	// the first word continuously.
	pChannelData->n_loopstart = pChannelData->n_sfxptr;
	pChannelData->n_replen = uwRepeatLength;
	pChannelData->uwPeriod = pChannelData->uwPeriod;
	pChannelData->uwSfxWordLength = 0; // Don't call startSfx() again

	mt_dmaon |= pChannelData->uwDmaFlag; // DMA channel to enable on Timer B
}

void moreBlockedFx(
	UWORD uwCmd, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// Get cmd idx. See tModVoice's type definition for details.
	UBYTE ubCmdIdx = (uwCmd >> 8) & 0x0F;
#if defined(ACE_DEBUG_PTPLAYER)
	if(ubCmdIdx >= 16) {
		logWrite("ERR: blmorefx_tab index out of range: cmd %hu -> %hu\n", uwCmd, uwCmd >> 8);
	}
#endif
	blmorefx_tab[ubCmdIdx](uwCmd, pChannelData, pChannelReg);
}

static void mt_updatefunk(tChannelStatus *pChannelData) {
	UBYTE ubVal = mt_FunkTable[pChannelData->uwFunkSpeed];
	pChannelData->n_funkoffset += ubVal;
	if(pChannelData->n_funkoffset > 0) {
		return;
	}
	pChannelData->n_funkoffset = 0;
	UBYTE *pOffs = (UBYTE*)&pChannelData->n_loopstart[pChannelData->n_replen];
	UBYTE *pWaveStart = &pChannelData->n_wavestart[1];
	if(pWaveStart >= pOffs) {
		pWaveStart = pOffs;
	}
	pChannelData->n_wavestart = pWaveStart;
	*pWaveStart = ~*pWaveStart;
}

static void checkmorefx(
	UWORD uwCmd, UWORD uwCmdArg,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	if(pChannelData->uwFunkSpeed) {
		mt_updatefunk(pChannelData);
	}
#if defined(ACE_DEBUG_PTPLAYER)
	if(uwCmd >= 16) {
		logWrite("ERR: morefx_tab index out of range: cmd %hu\n", uwCmd);
	}
#endif
	morefx_tab[uwCmd](uwCmdArg, pChannelData, pChannelReg);
}

static void mt_playvoice(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg,
	const tModVoice *pVoice
) {
	if(!pChannelData->isEnabledForPlayer) {
		return;
	}
	if(pChannelData->ubSfxPriority) {
		// Channel is blocked by external sound effect
		if(pChannelData->uwSfxWordLength) {
			// There are pending sfx data to be written into channel regs
			startSfx(pChannelData, pChannelReg);
			moreBlockedFx(pVoice->uwCmd, pChannelData, pChannelReg);
			return;
		}
		if(!isChannelDone(pChannelData) || (mt_dmaon & pChannelData->uwDmaFlag)) {
			// Channel interrupt is not triggered or DMA is still active - do only
			// some limited commands while sound effect is in progress
			moreBlockedFx(pVoice->uwCmd, pChannelData, pChannelReg);
			return;
		}
		// Sound effect sample is already scheduled to be played, so unblock
		// this channel again.
		pChannelData->ubSfxPriority = 0;
	}
	// n_note/cmd: any note or cmd set?
	if(!pChannelData->sVoice.ulData) {
		pChannelReg->ac_per = pChannelData->uwPeriod;
	}
	pChannelData->sVoice.ulData = pVoice->ulData;

	UWORD uwCmd = pChannelData->sVoice.ubCmdHi & 0x000F;
	UWORD uwCmdArg = pChannelData->sVoice.ubCmdLo;
	UWORD uwMaskedCmdE = pChannelData->sVoice.uwCmd & 0x0FF0;

	// Get sample start address from cmd/note - BA is sample number
	UWORD uwSampleIdx = ( // A...B... -> ......BA
		((pVoice->uwNote & 0xF000) >> 4) | (pVoice->ubCmdHi & 0xF0)
	) >> 4;
	if(uwSampleIdx) {
		// Samples are internally zero-based, in file 1-based
		--uwSampleIdx;
		// Read length, volume and repeat from sample info table
		UWORD *pSampleStart = mt_SampleStarts[uwSampleIdx];
		tPtplayerSampleHeader *pSampleDef = &mt_mod->pSampleHeaders[uwSampleIdx];
		UWORD uwSampleLength = pSampleDef->uwLength;
		if(!uwSampleLength) {
			// Use the first two bytes from the first sample for empty samples
			uwSampleIdx = 0;
			pSampleStart = mt_SampleStarts[uwSampleIdx];
			uwSampleLength = 1;
		}

		if(!pSampleStart) {
			logWrite(
				"ERR: Malformed MOD: start offset of sample %hu is zero\n",
				uwSampleIdx
			);
		}

		// logWrite("playvoice sample: %hu, length: %hu\n", uwSampleIdx, uwSampleLength);
		pChannelData->n_start = pSampleStart;
		pChannelData->n_reallength = uwSampleLength;

		// Determine period table from fine-tune parameter
		// TODO: sanitize this value to only have lower nibble set when loading MOD/samplepack
		UBYTE ubFineTune = pSampleDef->ubFineTune & 0xF;
		pChannelData->pPeriodTable = mt_PeriodTables[ubFineTune];
		pChannelData->n_minusft = (ubFineTune >= 8);

		pChannelData->uwVolume = pSampleDef->ubVolume;
		// MOD spec: repeat only if repeat length is bigger than 2 bytes.
		if(pSampleDef->uwRepeatLength <= 1) {
			// No repeat def - reload first empty sample word after playback,
			// then disable channel.
			pChannelData->isLooped = 0;
			pChannelData->n_replen = 1;
		}
		else {
			// Set repeat
			pChannelData->isLooped = 1;
			pChannelData->n_replen = pSampleDef->uwRepeatLength;
			uwSampleLength = pSampleDef->uwRepeatLength;
			pSampleStart += pSampleDef->uwRepeatOffs;
		}

		// set_loop:
		pChannelData->n_length = uwSampleLength;
		pChannelData->n_loopstart = pSampleStart;
		pChannelData->n_wavestart = (UBYTE*)pSampleStart;
		pChannelReg->ac_vol = mt_MasterVolTab[pSampleDef->ubVolume];
	}

	// inlined set_regs function here:
	if(!(pVoice->uwNote & 0xFFF)) {
		checkmorefx(uwCmd, uwCmdArg, pChannelData, pChannelReg);
	}
	else if(uwMaskedCmdE == 0x0E50) {
		set_finetune(uwCmd, uwCmdArg, uwMaskedCmdE, pVoice, pChannelData, pChannelReg);
	}
	else {
#if defined(ACE_DEBUG_PTPLAYER)
		if(uwCmd >= 16) {
			logWrite("ERR: prefx_tab index out of range: cmd %hu\n", uwCmd);
		}
#endif
		prefx_tab[uwCmd](
			uwCmd, uwCmdArg, uwMaskedCmdE, pVoice, pChannelData, pChannelReg
		);
	}
}

static void mt_checkfx(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	if(!pChannelData->isEnabledForPlayer) {
		return;
	}
	if(pChannelData->ubSfxPriority) {
		UWORD uwLen = pChannelData->uwSfxWordLength;
		if(uwLen) {
			startSfx(pChannelData, pChannelReg);
		}
		if(
			// mt_dmaon should be checked here to see if channel will be busy by sfx
			// but uwLen check is used instead.
			uwLen || !isChannelDone(pChannelData) ||
			(g_pCustom->dmaconr & pChannelData->uwDmaFlag)
		) {
			// Channel is blocked, only check some E-commands
			UWORD uwCmd = pChannelData->sVoice.uwCmd & 0x0FFF;
			if((uwCmd & 0xF00) == 0xE00) {
				blocked_e_cmds(uwCmd, pChannelData, pChannelReg);
			}
			return;
		}

		// Sound effect sample has played, so unblock this channel again
		pChannelData->ubSfxPriority = 0;
	}

	// Do channel effects between notes
	if(pChannelData->uwFunkSpeed) {
		mt_updatefunk(pChannelData);
	}
	UWORD uwCmd = (pChannelData->sVoice.uwCmd & 0x0FFF);
	if(!uwCmd) {
		// Just set the current period - same as mt_pernop
		pChannelReg->ac_per = pChannelData->uwPeriod;
	}
	else {
		UBYTE ubCmdIndex = (pChannelData->sVoice.ubCmdHi & 0xF);
#if defined(ACE_DEBUG_PTPLAYER)
		if(ubCmdIndex >= 16) {
			logWrite("ERR: fx_tab index out of range: cmd %hhu\n", ubCmdIndex);
		}
#endif
		fx_tab[ubCmdIndex](pChannelData->sVoice.ubCmdLo, pChannelData, pChannelReg);
	}
}

static void mt_sfxonly(void);
static void mt_music(void);

static void intPlay() {
	// it was a TA interrupt, do music when enabled
	if(mt_Enable) {
		mt_music();
	}
	else {
		// no music, only sfx
		mt_sfxonly();
	}
}

// TimerA interrupt calls _mt_music at a selectable tempo (Fxx command),
// which defaults to 50 times per second.
static void mt_TimerAInt(
	UNUSED_ARG REGARG(volatile tCustom *pCustom, "a0"),
	UNUSED_ARG REGARG(volatile void *pData, "a1")
) {
#if defined(PTPLAYER_DEFER_INTERRUPTS)
	s_isPendingPlay = 1;
#else
	intPlay();
#endif
}

static inline void ptplayerEnableMainHandler(UBYTE isEnabled) {
#if defined(PTPLAYER_USE_VBL)
	if(isEnabled) {
		systemSetInt(INTB_VERTB, mt_TimerAInt, 0);
	}
	else {
		systemSetInt(INTB_VERTB, 0, 0);
	}
#else
	if(isEnabled) {
		systemSetCiaInt(CIA_B, CIAICRB_TIMER_A, mt_TimerAInt, 0);
	}
	else {
		systemSetCiaInt(CIA_B, CIAICRB_TIMER_A, 0, 0);
	}
#endif
}

static inline void setChannelRepeat(
	volatile tChannelRegs *pChannelRegs, tChannelStatus *pChannelData
) {
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	if(pChannelData->n_replen == 1) {
		// Looped single word of sample - channel is to be set to idle mode
		if(mt_dmaon & pChannelData->uwDmaFlag) {
			// Channel is still on - give the audio interrupt signal that it should
			// disable channel DMA after playback of this one.
			s_pAudioChannelPendingDisable[pChannelData->ubChannelIndex] = 1;
		}
	}
#endif
	if(!(mt_dmaon & pChannelData->uwDmaFlag)) {
		// Channel is already turned off - refresh 'done' bit.
		setAudioDone(pChannelData);
		// Skip register setup
		return;
	}

	// Paula reads new register values after it finishes current audio playback.
	pChannelRegs->ac_ptr = pChannelData->n_loopstart;
	pChannelRegs->ac_len = pChannelData->n_replen;
}

static void intSetRep(volatile tCustom *pCustom) {
	// check and clear CIAB interrupt flags
	// clear EXTER and possible audio interrupt flags
	clearAudioDone();

	// Set repeat sample pointers and lengths
	if(mt_chan[0].isEnabledForPlayer) {
		setChannelRepeat(&pCustom->aud[0], &mt_chan[0]);
	}
	if(mt_chan[1].isEnabledForPlayer) {
		setChannelRepeat(&pCustom->aud[1], &mt_chan[1]);
	}
	if(mt_chan[2].isEnabledForPlayer) {
		setChannelRepeat(&pCustom->aud[2], &mt_chan[2]);
	}
	if(mt_chan[3].isEnabledForPlayer) {
		setChannelRepeat(&pCustom->aud[3], &mt_chan[3]);
	}

	// restore TimerA music interrupt vector
	ptplayerEnableMainHandler(1);
}

static void intDmaOn() {
	// Restart timer to set repeat, enable DMA
	systemSetCiaCr(CIA_B, 1, CIACRB_LOAD | CIACRB_RUNMODE | CIACRB_START);
	systemSetDmaMask(mt_dmaon, 1);
	ptplayerEnableMainHandler(0);
}

// One-shot TimerB interrupt to enable audio DMA after DMA_DELAY ticks.
static void mt_TimerBInt(
	REGARG(volatile tCustom *pCustom, "a0"),
	UNUSED_ARG REGARG(volatile void *pData, "a1")
) {
	// Do DMA on first, then Set Repeat
	UBYTE isSetRep = s_isNextTimerBSetRep;
	s_isNextTimerBSetRep = !s_isNextTimerBSetRep;
#if defined(PTPLAYER_DEFER_INTERRUPTS)
	if(isSetRep) {
		s_isPendingSetRep = 1;
	}
	else {
		s_isPendingDmaOn = 1;
	}
#else
	if(isSetRep) {
		intSetRep(pCustom);
	}
	else {
		intDmaOn();
	}
#endif
}

static void chan_sfx_only(
	volatile tChannelRegs *pChannelReg, tChannelStatus *pChannelData
) {
	if(pChannelData->ubSfxPriority) {
		if(pChannelData->uwSfxWordLength) {
			startSfx(pChannelData, pChannelReg);
		}
		else if(isChannelDone(pChannelData) && !(mt_dmaon & pChannelData->uwDmaFlag)) {
			// Last sound effect sample has played, so unblock this channel again
			pChannelData->ubSfxPriority = 0;
		}
	}
}

// Called from interrupt.
// Plays sound effects on free channels.
void mt_sfxonly(void) {
	mt_dmaon = 0;
	chan_sfx_only(&g_pCustom->aud[0], &mt_chan[0]);
	chan_sfx_only(&g_pCustom->aud[1], &mt_chan[1]);
	chan_sfx_only(&g_pCustom->aud[2], &mt_chan[2]);
	chan_sfx_only(&g_pCustom->aud[3], &mt_chan[3]);

	if(mt_dmaon) {
		ptplayerEnableMainHandler(0);
		systemSetCiaCr(CIA_B, 1, CIACRB_LOAD | CIACRB_RUNMODE | CIACRB_START); // load/start timer B, one-shot
	}
}

/**
 * @brief The replayer routine.
 * Is called automatically from interrupt after ptplayerCreate().
 * Plays next position when Counter equals Speed. Effects are always handled.
 */
static void mt_music(void) {
	mt_dmaon = 0;
	if(++mt_Counter < mt_Speed) {
		// no new note, just check effects, don't step to next position
		mt_checkfx(&mt_chan[0], &g_pCustom->aud[0]);
		mt_checkfx(&mt_chan[1], &g_pCustom->aud[1]);
		mt_checkfx(&mt_chan[2], &g_pCustom->aud[2]);
		mt_checkfx(&mt_chan[3], &g_pCustom->aud[3]);

		// set one-shot TimerB interrupt for enabling DMA, when needed
		if(mt_dmaon) {
			ptplayerEnableMainHandler(0);
			systemSetCiaCr(CIA_B, 1, CIACRB_LOAD | CIACRB_RUNMODE | CIACRB_START); // load/start timer B, one-shot
		}
	}
	else {
		// handle a new note
		mt_Counter = 0;
		if(mt_PattDelTime2 <= 0) {
			// determine pointer to current pattern line
			UBYTE *pPatternData = mt_mod->pPatterns;
			UBYTE *pArrangement = mt_mod->pArrangement;
			UBYTE ubPatternIdx = pArrangement[mt_SongPos];
			UBYTE *pCurrentPattern = &pPatternData[ubPatternIdx * 1024];
			tModVoice *pLineVoices = (tModVoice*)&pCurrentPattern[mt_PatternPos];
			printVoices(pLineVoices);

			// play new note for each channel, apply some effects
			mt_playvoice(&mt_chan[0], &g_pCustom->aud[0], &pLineVoices[0]);
			mt_playvoice(&mt_chan[1], &g_pCustom->aud[1], &pLineVoices[1]);
			mt_playvoice(&mt_chan[2], &g_pCustom->aud[2], &pLineVoices[2]);
			mt_playvoice(&mt_chan[3], &g_pCustom->aud[3], &pLineVoices[3]);
		}
		else {
			// we have a pattern delay, check effects then step
			mt_checkfx(&mt_chan[0], &g_pCustom->aud[0]);
			mt_checkfx(&mt_chan[1], &g_pCustom->aud[1]);
			mt_checkfx(&mt_chan[2], &g_pCustom->aud[2]);
			mt_checkfx(&mt_chan[3], &g_pCustom->aud[3]);
		}
		// set one-shot TimerB interrupt for enabling DMA, when needed
		if(mt_dmaon) {
			ptplayerEnableMainHandler(0);
			systemSetCiaCr(CIA_B, 1, CIACRB_LOAD | CIACRB_RUNMODE | CIACRB_START); // load/start timer B, one-shot
		}

		// next pattern line, handle delay and break
		mt_SilCntValid = 0; // recalculate silence counters
		UBYTE ubOffs = 16; // Offset to next pattern line
		UBYTE ubPatternDelay = mt_PattDelTime2;
		if(mt_PattDelTime) {
			ubPatternDelay = mt_PattDelTime;
			mt_PattDelTime = 0;
		}
		// logWrite("pattern delay: %hhu\n", ubPatternDelay);
		if(ubPatternDelay) {
			--ubPatternDelay;
			if(ubPatternDelay) {
				ubOffs = 0; // Do not advance to next line
			}
			else {
				// logWrite("Advance to next line\n");
			}
			mt_PattDelTime2 = ubPatternDelay;
		}
		UWORD uwNextLinePos = mt_PatternPos + ubOffs;

		// Check for break
		if(mt_PBreakFlag) {
			mt_PBreakFlag = 0;
			uwNextLinePos = mt_PBreakPos;
			mt_PBreakPos = 0;
		}

		// Check whether end of pattern is reached
		mt_PatternPos = uwNextLinePos;
		if(uwNextLinePos >= 1024) {
			ptSongStep();
		}
	}
	if(mt_PosJumpFlag) {
		ptSongStep();
	}
}

/**
 * @brief Resets channel status. All registers are preserved!
 *
 * @param pChannel
 */
static void resetChannel(tChannelStatus *pChannel) {
	pChannel->uwPeriod = 320; // make sure period is not illegal
	pChannel->uwVolume = 0;
	pChannel->uwSfxWordLength = 0;
	pChannel->uwFunkSpeed = 0;
	pChannel->ubSfxPriority = 0;
	pChannel->isLooped = 0;
	pChannel->n_gliss = 0;
}

// Stop playing current module.
void ptplayerStop(void) {
	ptplayerEnableMusic(0);
	for(UBYTE i = 0; i < 4; ++i) {
		if(mt_chan[i].isEnabledForPlayer) {
			systemSetDmaMask(mt_chan[i].uwDmaFlag, 0);
		}
		resetChannel(&mt_chan[i]);
	}
	s_pModCurr = 0;

	// Free the channels taken by SFX.
	// Typically they would release themselves but turning off DMA prevents this.
	mt_chan[0].ubSfxPriority = 0;
	mt_chan[1].ubSfxPriority = 0;
	mt_chan[2].ubSfxPriority = 0;
	mt_chan[3].ubSfxPriority = 0;
}

static inline void setTempo(UWORD uwTempo) {
#if !defined(PTPLAYER_USE_VBL)
	systemSetTimer(CIA_B, 0, mt_timerval / uwTempo);
#endif
}

static void mt_reset(void) {
	// Load TimerA in continuous mode for the default tempo of 125.
	// Note to self: make sure this is called when changing MODs.
	setTempo(125);
#if !defined(PTPLAYER_USE_VBL)
	systemSetCiaCr(CIA_B, 0, CIACRA_LOAD | CIACRA_START); // load timer, start continuous
#endif

	// Load TimerB with DMA_DELAY ticks for setting DMA and repeat
	systemSetTimer(CIA_B, 1, DMA_DELAY);

	// Enable CIA B interrupts
	g_pCustom->intena = INTF_SETCLR | INTF_EXTER;

	// reset speed and counters
	mt_Speed = 6;
	mt_Counter = 0;
	mt_PatternPos = 0;
	mt_PattDelTime = 0;
	mt_PattDelTime2 = 0;
	mt_PBreakPos = 0;
	mt_PBreakFlag = 0;
	mt_PosJumpFlag = 0;

#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	// Set all channels as done in case of waiting for sfx before any have been
	// actually played.
	s_uChannelDone.ulChannelMask = 0x01010101;
#endif

	// Disable the filter
	g_pCia[CIA_A]->pra |= BV(1);

	// initialise channel DMA, interrupt bits and audio register base
	// make sure uwPeriod doesn't start as 0
	// disable sound effects
	for(UBYTE i = 4; i--;) {
		mt_chan[i].uwDmaFlag = 1 << (DMAB_AUD0 + i);
	#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
		mt_chan[i].ubChannelIndex = i;
		mt_chan[i].pDoneBit = &s_uChannelDone.pChannels[i];
	#endif
	}

	mt_SilCntValid = 0;
	mt_E8Trigger = 0;
	s_isNextTimerBSetRep = 0;
	ptplayerStop();
}

#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
static void INTERRUPT onAudio(
	REGARG(volatile tCustom *pCustom, "a0"),
	REGARG(volatile void *pData, "a1")
) {
	UBYTE ubChannelIndex = (ULONG)pData;
	s_uChannelDone.pChannels[ubChannelIndex] = 1;

	if(s_pAudioChannelPendingDisable[ubChannelIndex]) {
		// This is to prevent repeatedly triggering audio interrupt and slowing
		// Amiga down after sfx playback.
		s_pAudioChannelPendingDisable[ubChannelIndex] = 0;
		systemSetDmaMask(DMAF_AUD0 << ubChannelIndex, 0);
		pCustom->aud[ubChannelIndex].ac_dat = 0;
	}
};
#endif

void ptplayerDestroy(void) {
	ptplayerStop();
	// Disable handling of music
	ptplayerEnableMusic(0);
	ptplayerEnableMainHandler(0);
	systemSetCiaInt(CIA_B, CIAICRB_TIMER_B, 0, 0);
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	systemSetInt(INTB_AUD0, 0, 0);
	systemSetInt(INTB_AUD1, 0, 0);
	systemSetInt(INTB_AUD2, 0, 0);
	systemSetInt(INTB_AUD3, 0, 0);
#endif
}

void ptplayerCreate(UBYTE isPal) {
	s_isRepeat = 1;
	s_cbSongEnd = 0;
	s_pModCurr = 0;
	ptplayerEnableMusic(0);
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	for(UBYTE i = sizeof(s_pAudioChannelPendingDisable); i--;) {
		s_pAudioChannelPendingDisable[i] = 0;
	}
#endif
#if defined(PTPLAYER_DEFER_INTERRUPTS)
	s_isPendingDmaOn = 0;
	s_isPendingPlay = 0;
	s_isPendingSetRep = 0;
#endif

	// disable CIA B interrupts, set player interrupt vector
	g_pCustom->intena = INTF_EXTER;
	ptplayerEnableMainHandler(1);
	systemSetCiaInt(CIA_B, CIAICRB_TIMER_B, mt_TimerBInt, 0);
#if defined(PTPLAYER_USE_AUDIO_INT_HANDLERS)
	systemSetInt(INTB_AUD0, onAudio, (void*)0);
	systemSetInt(INTB_AUD1, onAudio, (void*)1);
	systemSetInt(INTB_AUD2, onAudio, (void*)2);
	systemSetInt(INTB_AUD3, onAudio, (void*)3);
#endif

	ptplayerSetPal(isPal);
	mt_MasterVolTab = MasterVolTab[64];
	for(UBYTE i = 0; i < 4; ++i) {
		mt_chan[i].isEnabledForPlayer = 1;
	}
	mt_reset();
}

void ptplayerSetPal(UBYTE isPal) {
	// determine if 02 clock for timers is based on PAL or NTSC
	s_isPal = isPal;
	if(s_isPal) {
		// Fcolor = 4.43361825 MHz (PAL color carrier frequency)
		// CPU Clock = Fcolor * 1.6 = 7.0937892 MHz
		// CIA Clock = Cpu Clock / 10 = 709.37892 kHz
		// 50 Hz Timer = CIA Clock / 50 = 14187.5784
		// Tempo num. = 50 Hz Timer*125 = 1773447
		mt_timerval = 1773447;
	}
	else {
		mt_timerval = 1789773;
	}
}

void ptplayerLoadMod(
	tPtplayerMod *pMod, tPtplayerSamplePack *pExternalSamples,
	UWORD uwInitialSongPos
) {
	logBlockBegin(
		"ptplayerLoadMod(pMod: %p, pExternalSamples: %p, uwInitialSongPos: %hu)",
		pMod, pExternalSamples, uwInitialSongPos
	);

	// Initialize new module.
	// Reset speed to 6, tempo to 125 and start at given song position.
	// Master volume is at 64 (maximum).
	mt_mod = pMod;
	logWrite(
		"Song name: '%s', arrangement length: %hhu, end pos: %hhu\n",
		mt_mod->szSongName, mt_mod->ubArrangementLength, mt_mod->ubSongEndPos
	);

	// set initial song position
	if(uwInitialSongPos >= 950) {
		uwInitialSongPos = 0;
	}
	mt_SongPos = uwInitialSongPos;

	// sample data location is given?
	if(pExternalSamples) {
		logWrite("Using sample data from: %p\n", pExternalSamples);

		// Save start address of each sample in contiguous sample data
		ULONG ulOffs = 0;
		for(UBYTE i = 0; i < PTPLAYER_MOD_SAMPLE_COUNT; ++i) {
			mt_SampleStarts[i] = &pExternalSamples->pData[ulOffs];
			ulOffs += mt_mod->pSampleHeaders[i].uwLength;
		};
	}
	else {
		for(UBYTE i = 0; i < PTPLAYER_MOD_SAMPLE_COUNT; ++i) {
			mt_SampleStarts[i] = pMod->pSampleStarts[i];
		}
	}

	for(UBYTE i = 0; i < PTPLAYER_MOD_SAMPLE_COUNT; ++i) {
		const tPtplayerSampleHeader *pHeader = &mt_mod->pSampleHeaders[i];
		if(mt_mod->pSampleHeaders[i].uwLength > 0) {
			// Make sure each sample starts with two 0-bytes
			mt_SampleStarts[i][0] = 0;
			logWrite(
				"Sample %hhu name: '%.*s', word length: %hu, start: %p, repeat offs: %hu, repeat len:%hu\n",
				i, 22, pHeader->szName, pHeader->uwLength,
				mt_SampleStarts[i], pHeader->uwRepeatOffs, pHeader->uwRepeatLength
			);
			if(pHeader->uwRepeatOffs + pHeader->uwRepeatLength > pHeader->uwLength) {
				logWrite("ERR: Repeat offs + repeat length > length\n");
			}
		}
	}

	mt_reset();
	s_pModCurr = pMod;
	logBlockEnd("ptplayerLoadMod()");
}

void ptplayerSetMusicChannelMask(UBYTE ChannelMask) {
	g_pCustom->intena = INTF_INTEN;
	mt_chan[0].isOnlyForMusic = BTST(ChannelMask, 0);
	mt_chan[1].isOnlyForMusic = BTST(ChannelMask, 1);
	mt_chan[2].isOnlyForMusic = BTST(ChannelMask, 2);
	mt_chan[3].isOnlyForMusic = BTST(ChannelMask, 3);

	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

static void setAllVolumes(void) {
	// Only set volume for channels used in MOD playback.
	if (!mt_chan[0].ubSfxPriority && mt_chan[0].isEnabledForPlayer) {
		g_pCustom->aud[0].ac_vol = mt_MasterVolTab[mt_chan[0].uwVolume];
	}
	if (!mt_chan[1].ubSfxPriority && mt_chan[1].isEnabledForPlayer) {
		g_pCustom->aud[1].ac_vol = mt_MasterVolTab[mt_chan[1].uwVolume];
	}
	if (!mt_chan[2].ubSfxPriority && mt_chan[2].isEnabledForPlayer) {
		g_pCustom->aud[2].ac_vol = mt_MasterVolTab[mt_chan[2].uwVolume];
	}
	if (!mt_chan[3].ubSfxPriority && mt_chan[3].isEnabledForPlayer) {
		g_pCustom->aud[3].ac_vol = mt_MasterVolTab[mt_chan[3].uwVolume];
	}
}

void ptplayerSetMasterVolume(UBYTE ubMasterVolume) {
	// TODO: expose define which would make this function calculate current volume
	// table instead of toring 4KB of table data.
	g_pCustom->intena = INTF_INTEN;

	// Set new table and adapt all channel volumes immediately
	mt_MasterVolTab = MasterVolTab[ubMasterVolume];
	setAllVolumes();

	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

void ptplayerSetChannelsForPlayer(UBYTE ubChannelMask) {
	g_pCustom->intena = INTF_INTEN;
	mt_chan[0].isEnabledForPlayer = BTST(ubChannelMask, 0);
	mt_chan[1].isEnabledForPlayer = BTST(ubChannelMask, 1);
	mt_chan[2].isEnabledForPlayer = BTST(ubChannelMask, 2);
	mt_chan[3].isEnabledForPlayer = BTST(ubChannelMask, 3);
	setAllVolumes();
	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

//-------------------------------------------------- COMMANDS WITHOUT CMD PASSED

static void mt_toneporta_nc(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	if(pChannelData->n_wantedperiod) {
		WORD wNew;
		if(pChannelData->uwPeriod > pChannelData->n_wantedperiod) {
			// tone porta up
			wNew = pChannelData->uwPeriod - pChannelData->n_toneportspeed;
			if(wNew < pChannelData->n_wantedperiod) {
				wNew = pChannelData->n_wantedperiod;
				pChannelData->n_wantedperiod = 0;
			}
		}
		else {
			// tone porta down
			wNew = pChannelData->uwPeriod + pChannelData->n_toneportspeed;
			if(wNew > pChannelData->n_wantedperiod) {
				wNew = pChannelData->n_wantedperiod;
				pChannelData->n_wantedperiod = 0;
			}
		}
		pChannelData->uwPeriod = wNew;
		if(pChannelData->n_gliss) {
			// glissando: find nearest note for new period
			const UWORD *pPeriodTable = pChannelData->pPeriodTable;
			UWORD uwNoteOffs = 0;
			UBYTE ubPeriodPos = findPeriod(pChannelData->pPeriodTable, uwNoteOffs);
			pChannelData->n_noteoff = ubPeriodPos * 2;
			wNew = pPeriodTable[ubPeriodPos];
		}
		pChannelReg->ac_per = wNew;
	}
}

static void mt_vibrato_nc(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg,
	UBYTE ubAmplitude, UBYTE ubSpeed
) {
	// calculate vibrato table offset
	UBYTE ubOffs = 64 * ubAmplitude + (pChannelData->n_vibratopos & 63);

	// select vibrato waveform
	const BYTE *pTable;
	UBYTE ubCtl = pChannelData->n_vibratoctrl & 3;
	if(!ubCtl) {
		pTable = mt_VibratoSineTable;
	}
	else if(ubCtl == 1) {
		pTable = mt_VibratoSawTable;
	}
	else {
		// ctrl 2 & 3 select a rectangle vibrato
		pTable = mt_VibratoRectTable;
	}

	// add vibrato-offset to period
	pChannelReg->ac_per = pChannelData->uwPeriod + pTable[ubOffs];

	// Increase vibratopos by speed
	pChannelData->n_vibratopos += ubSpeed;
}

//-------------------------------------------------------- EFFECTS WITH CMD WORD

static void mt_nop(
	UNUSED_ARG UBYTE ubArgs, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {

}

static void mt_arpeggio(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x00'XY (x = first arpeggio offset, y = second arpeggio offset)
	static const BYTE pArpTab[] = {
		0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0,
		1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1
	};

	// Step 0, just use normal period
	pChannelReg->ac_per = pChannelData->uwPeriod;

	UWORD uwVal;
	if(pArpTab[mt_Counter] >= 0) {
		// Step 1, arpeggio by left nibble
		uwVal = ubArgs >> 4;
	}
	else {
		// Step 2, arpeggio by right nibble
		uwVal = ubArgs & 0xF;
	}
	// offset current note
	uwVal *= 2;
	uwVal += pChannelData->n_noteoff;
	if(uwVal < 2 * 36) {
		// Set period with arpeggio offset from note table
		pChannelReg->ac_per = pChannelData->pPeriodTable[uwVal / 2];
		// TODO later: noteoff has byte offs from start of array, set it to divided
		// by 2 since we're using UWORD pointers, not UBYTE
	}
}

static void ptDoPortaUp(
	UBYTE ubVal, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	UWORD uwNewPer = MAX(113, pChannelData->uwPeriod - ubVal);
	pChannelData->uwPeriod = uwNewPer;
	pChannelReg->ac_per = uwNewPer;
}

static void mt_portaup(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// cmd 1 x x (subtract xx from period)
	ptDoPortaUp(ubArgs, pChannelData, pChannelReg);
}

static void ptDoPortaDn(
	UBYTE ubVal, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	UWORD uwNewPer = MIN(pChannelData->uwPeriod + ubVal, 856);
	pChannelData->uwPeriod = uwNewPer;
	pChannelReg->ac_per = uwNewPer;
}

static void mt_portadown(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// cmd 2 x x (add xx to period)
	ptDoPortaDn(ubArgs, pChannelData, pChannelReg);
}

static void mt_toneporta(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x03'XY (xy = tone portamento speed)
	if(ubArgs) {
		pChannelData->n_toneportspeed = ubArgs;
		pChannelData->sVoice.ubCmdLo = 0;
	}
	mt_toneporta_nc(pChannelData, pChannelReg);
}

static void mt_vibrato(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x04'XY (x = speed, y = amplitude)
	UBYTE ubAmplitude = ubArgs & 0xF;
	if(ubAmplitude) {
		pChannelData->n_vibratoamp = ubAmplitude;
	}
	else {
		ubAmplitude = pChannelData->n_vibratoamp;
	}
	UBYTE ubSpeed = ubArgs >> 4;
	if(ubSpeed) {
		pChannelData->n_vibratospd = ubSpeed;
	}
	else {
		ubSpeed = pChannelData->n_vibratospd;
	}
	mt_vibrato_nc(pChannelData, pChannelReg, ubAmplitude, ubSpeed);
}

static void ptVolSlide(
	BYTE bVolNew, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	bVolNew = CLAMP(bVolNew, 0, 64);
	pChannelData->uwVolume = bVolNew;
	pChannelReg->ac_per = pChannelData->uwPeriod;
	pChannelReg->ac_vol = mt_MasterVolTab[bVolNew];
}

static void mt_volumeslide(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0A'XY (x = volume-up, y = volume-down)
	UBYTE ubVolDn  = ubArgs & 0x0F;
	UBYTE ubVolUp = ubArgs >> 4;

	BYTE bVol = pChannelData->uwVolume;
	if(ubVolUp) {
		// Slide up, until 64
		ptVolSlide(bVol + ubVolUp, pChannelData, pChannelReg);
	}
	else {
		// Slide down, until 0
		ptVolSlide(bVol - ubVolDn, pChannelData, pChannelReg);
	}
}

static void mt_tonevolslide(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x05'XY (x = volume up, y = volume down)
	mt_toneporta_nc(pChannelData, pChannelReg);

	// Do a volume slide with current cmd's args
	mt_volumeslide(ubArgs, pChannelData, pChannelReg);
}

static void mt_vibrvolslide(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x06'XY (x = volume-up, y = volume-down)

	// Do vibrato with previously stored args
	mt_vibrato_nc(
		pChannelData, pChannelReg,
		pChannelData->n_vibratoamp, pChannelData->n_vibratospd
	);

	// Do a volume slide with current cmd's args
	mt_volumeslide(ubArgs, pChannelData, pChannelReg);
}

static void mt_tremolo(
	UBYTE ubArgs, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x07'XY (x = speed, y = amplitude)
	UBYTE ubAmplitude = ubArgs & 0x0F;
	UBYTE ubSpeed = ubArgs >> 4;
	if(ubAmplitude) {
		pChannelData->n_tremoloamp = ubAmplitude;
	}
	else {
		ubAmplitude = pChannelData->n_tremoloamp;
	}
	if(ubSpeed) {
		pChannelData->n_tremolospd = ubSpeed;
	}
	else {
		ubSpeed = pChannelData->n_tremolospd;
	}

	// calculate tremolo table offset
	UWORD uwOffset = 64 * ubAmplitude + (pChannelData->n_tremolopos & 63);

	// select tremolo waveform
	UBYTE ubWaveformIdx = pChannelData->n_tremoloctrl & 3;
	const BYTE *pWaveform;
	if(ubWaveformIdx == 0) {
		// ctrl 0 selects a sine tremolo
		pWaveform = mt_VibratoSineTable;
	}
	else if(ubWaveformIdx == 1) {
		// ctrl 1 selects a sawtooth tremolo
		pWaveform = mt_VibratoSawTable;
	}
	else {
		// ctrl 2 & 3 select a rectangle tremolo
		pWaveform = mt_VibratoRectTable;
	}

	// add tremolo-offset to volume
	WORD wNewVol = pChannelData->uwVolume + pWaveform[uwOffset];
	wNewVol = CLAMP(wNewVol, 0, 64);

	pChannelReg->ac_per = pChannelData->uwPeriod;
	pChannelReg->ac_vol = wNewVol;

	// increase tremolopos by speed
	pChannelData->n_tremolopos += ubSpeed;
}

static void mt_e_cmds(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0E'XY (x = command, y = argument)
	UBYTE ubArgE = ubArgs & 0x0F;
	UBYTE ubCmdE = (ubArgs & 0xF0) >> 4;
#if defined(ACE_DEBUG_PTPLAYER)
	if(ubCmdE >= 16) {
		logWrite("ERR: ecmd_tab index out of range: cmd %hhu\n", ubCmdE);
	}
#endif
	ecmd_tab[ubCmdE](ubArgE, pChannelData, pChannelReg);
}

/**
 * @brief Protracker commands
 */
static const tFx fx_tab[16] = {
	mt_arpeggio,
	mt_portaup,
	mt_portadown,
	mt_toneporta,
	mt_vibrato,
	mt_tonevolslide,
	mt_vibrvolslide,
	mt_tremolo,
	mt_nop,
	mt_nop,
	mt_volumeslide,
	mt_nop,
	mt_nop,
	mt_nop,
	mt_e_cmds,
	mt_nop
};

//---------------------------------------------------------------- MORE FX TABLE

static void mt_posjump(
	UBYTE ubArgs, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0B'XY (xy = new song position)
	mt_SongPos = ubArgs - 1;
	mt_PBreakPos = 0;
	mt_PosJumpFlag = 1;
}

static void mt_patternbrk(
	UBYTE ubArgs, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0D'XY (xy = break pos in decimal)

	static const UBYTE pMult10[] = {
		0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 0, 0, 0, 0, 0, 0
	};

	UBYTE ubY = ubArgs & 0xF;
	UBYTE ubX = ubArgs >> 4;
	UBYTE ubVal = pMult10[ubX] + ubY;

	if(ubVal > 63) {
		mt_PBreakPos = 0;
	}
	else {
		mt_PBreakPos = ubVal << 4;
	}
	mt_PosJumpFlag = 1;
}

static void blocked_e_cmds(
	UBYTE ubArgs, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0E'XY (x = command, y = argument)
	UBYTE ubArg = ubArgs & 0x0F;
	UBYTE ubCmdE = (ubArgs & 0xF0) >> 4;
#if defined(ACE_DEBUG_PTPLAYER)
	if(ubCmdE >= 16) {
		logWrite("ERR: blecmd_tab index out of range: cmd %hhu\n", ubCmdE);
	}
#endif
	blecmd_tab[ubCmdE](ubArg, pChannelData, pChannelReg);
}

static void mt_setspeed(
	UBYTE ubArgs, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// uwCmd: 0x0F'XY (xy < 0x20: new speed, xy >= 0x20: new tempo)
	if(ubArgs < 0x20) {
		mt_Speed = ubArgs;
		if(!ubArgs) {
			ptplayerStop();
		}
	}
	else {
		// Set tempo (CIA only)
		setTempo(ubArgs);
	}
}

static void mt_pernop(
	UNUSED_ARG UBYTE ubArgs,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// just set the current period
	pChannelReg->ac_per = pChannelData->uwPeriod;
}

static void mt_volchange(
	UBYTE ubNewVolume,
	UNUSED_ARG tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd C x y (xy = new volume)
	if(ubNewVolume > 64) {
		ubNewVolume = 64;
	}
	pChannelReg->ac_vol = mt_MasterVolTab[ubNewVolume];
}

static void mt_sampleoffset(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 9 x y (xy = offset in 256's of bytes)
	// d4 = xy
	if(!ubArg) {
		ubArg = pChannelData->n_sampleoffset;
	}
	else {
		pChannelData->n_sampleoffset = ubArg;
	}

	// Offset is in 256s of bytes, length is in words
	UWORD uwLength = ubArg * (256 / sizeof(UWORD));
	if(uwLength < pChannelData->n_length) {
		pChannelData->n_length -= uwLength;
		pChannelData->n_start += uwLength;
	}
	else {
		pChannelData->n_length = 1;
	}
}

static const tFx blmorefx_tab[16] = {
	[0 ... 0x0A] = mt_nop,
	[0x0B] = mt_posjump,
	[0x0C] = mt_nop,
	[0x0D] = mt_patternbrk,
	[0x0E] = blocked_e_cmds,
	[0x0F] = mt_setspeed,
};

static const tFx morefx_tab[16] = {
	[0 ... 0x08] = mt_pernop,
	[0x09] = mt_sampleoffset,
	[0x0A] = mt_pernop,
	[0x0B] = mt_posjump,
	[0x0C] = mt_volchange,
	[0x0D] = mt_patternbrk,
	[0x0E] = mt_e_cmds,
	[0x0F] = mt_setspeed
};

//----------------------------------------------------------------- E CMDS TABLE

static void mt_filter(
	UBYTE ubArg, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'0X (x=1 disable, x=0 enable)
	if(ubArg & 1) {
		g_pCia[CIA_A]->pra |= BV(1);
	}
	else {
		g_pCia[CIA_A]->pra &= ~BV(1);
	}
}

static void mt_fineportaup(
	UBYTE ubArg, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'1X (subtract x from period)
	if(!mt_Counter) {
		ptDoPortaUp(ubArg, pChannelData, pChannelReg);
	}
}

static void mt_fineportadn(
	UBYTE ubArg, tChannelStatus *pChannelData,
	volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'1X (subtract x from period)
	if(!mt_Counter) {
		ptDoPortaDn(ubArg, pChannelData, pChannelReg);
	}
}

static void mt_glissctrl(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'3X (x = gliss)
	pChannelData->n_gliss = ubArg;
}

static void mt_vibratoctrl(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'4X (x = vibrato)
	pChannelData->n_vibratoctrl = ubArg;
}

static void mt_finetune(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'5X (x = finetune)
	pChannelData->pPeriodTable = mt_PeriodTables[ubArg];
	pChannelData->n_minusft = (ubArg >= 8);
}

static void mt_jumploop(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'6X (x = 0: loop start, else loop count)
	if(mt_Counter) {
		return;
	}
	if(!ubArg) {
		// remember start of loop position
		pChannelData->n_pattpos = mt_PatternPos;
		return;
	}
	// otherwise we are at the end of the loop
	--pChannelData->n_loopcount;
	if(!pChannelData->n_loopcount) {
		// loop finished
		return;
	}
	else if(pChannelData->n_loopcount < 0) {
		// initialize loop counter
		pChannelData->n_loopcount  = ubArg;
	}

	// jump back to start of loop
	mt_PBreakPos = pChannelData->n_pattpos;
	mt_PBreakFlag = 1;
}

static void mt_tremoctrl(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'7X (x = tremolo)
	pChannelData->n_tremoloctrl = ubArg;
}

static void mt_e8(
	UBYTE ubArg, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'8X (x = trigger value)
	mt_E8Trigger = ubArg;
}

static void ptDoRetrigger(
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// DMA off, set sample pointer and length
	systemSetDmaMask(pChannelData->uwDmaFlag, 0);
	// logWrite("retrigger: %p:%hu\n", pChannelData->n_start, pChannelData->n_length);
	pChannelReg->ac_ptr = pChannelData->n_start;
	pChannelReg->ac_len = pChannelData->n_length;
	mt_dmaon |= pChannelData->uwDmaFlag;
}

static void mt_retrignote(
	UBYTE ubArg, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'9X (x = retrigger count)
	if(!ubArg) {
		return;
	}

	// set new retrigger count when Counter = 0
	if(!mt_Counter) {
		pChannelData->n_retrigcount = ubArg;
		// avoid double retrigger, when Counter=0 and a note was set
		if(pChannelData->sVoice.uwNote & 0x0FFF) {
			return;
		}
	}
	else {
		// check if retrigger count is reached
		--pChannelData->n_retrigcount;
		if(pChannelData->n_retrigcount) {
			return;
		}
		// reset
		pChannelData->n_retrigcount = ubArg;
	}

	ptDoRetrigger(pChannelData, pChannelReg);
}

static void mt_volfineup(
	UBYTE ubArg, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'AX (x = volume add)
	if(!mt_Counter) {
		ptVolSlide(pChannelData->uwVolume + ubArg, pChannelData, pChannelReg);
	}
}

static void mt_volfinedn(
	UBYTE ubArg, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'BX (x = volume subtract)
	if(!mt_Counter) {
		ptVolSlide(pChannelData->uwVolume - ubArg, pChannelData, pChannelReg);
	}
}

static void mt_notecut(
	UBYTE ubArg, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'CX (x = counter to cut at)
	if(mt_Counter == ubArg) {
		pChannelData->uwVolume = 0;
		pChannelReg->ac_vol = 0;
	}
}

static void mt_notedelay(
	UBYTE ubArg, tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'DX (x = counter to retrigger at)
	if(mt_Counter == ubArg) {
		// Trigger note when given
		if(pChannelData->sVoice.uwNote) {
			pChannelReg->ac_per = pChannelData->uwPeriod;
			ptDoRetrigger(pChannelData, pChannelReg);
		}
	}
}

static void mt_patterndelay(
	UBYTE ubArg, UNUSED_ARG tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'EX (x = delay count)
	if(!mt_Counter && !mt_PattDelTime2) {
		mt_PattDelTime = ubArg + 1;
		// logWrite("set pattern delay: %hu\n", mt_PattDelTime);
	}
}

static void mt_funk(
	UBYTE ubArg, tChannelStatus *pChannelData,
	UNUSED_ARG volatile tChannelRegs *pChannelReg
) {
	// cmd 0x0E'FX (x = delay count)
	if(!mt_Counter) {
		pChannelData->uwFunkSpeed = ubArg;
		if(ubArg) {
			mt_updatefunk(pChannelData);
		}
	}
}

static const tEFn ecmd_tab[16] = {
	mt_filter,
	mt_fineportaup,
	mt_fineportadn,
	mt_glissctrl,
	mt_vibratoctrl,
	mt_finetune,
	mt_jumploop,
	mt_tremoctrl,
	mt_e8,
	mt_retrignote,
	mt_volfineup,
	mt_volfinedn,
	mt_notecut,
	mt_notedelay,
	mt_patterndelay,
	mt_funk
};

static const tEFn blecmd_tab[16] = {
	mt_filter,
	mt_nop, mt_nop,
	mt_glissctrl,
	mt_vibratoctrl,
	mt_finetune,
	mt_jumploop,
	mt_tremoctrl,
	mt_e8,
	mt_nop, mt_nop, mt_nop, mt_nop, mt_nop
};

static void set_period(
	UWORD uwCmd, UWORD uwCmdArg, UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	UWORD uwNote = pVoice->uwNote & 0xFFF;
	UBYTE ubPeriodPos = findPeriod(mt_PeriodTables[0], uwNote);

	// Apply finetuning, set period and note-offset
	UWORD uwPeriod = pChannelData->pPeriodTable[ubPeriodPos];
	pChannelData->uwPeriod = uwPeriod;
	pChannelData->n_noteoff = ubPeriodPos * 2; // TODO later: convert to word offs (div by 2)

	// Check for notedelay
	// logWrite("cmd: %04X, masked E: %04X\n", uwCmd, uwMaskedCmdE);
	// Skip if notedelay
	if(uwMaskedCmdE != 0x0ED0) {
		// Disable DMA
		systemSetDmaMask(pChannelData->uwDmaFlag, 0);

		if(!BTST(pChannelData->n_vibratoctrl, 2)) {
			pChannelData->n_vibratopos = 0;
		}
		if(!BTST(pChannelData->n_tremoloctrl, 2)) {
			pChannelData->n_tremolopos = 0;
		}
		// logWrite(
		// 	"setperiod: ptr %p, len: %hu, period: %hu\n",
		// 	pChannelData->n_start, pChannelData->n_length, uwPeriod
		// );

		pChannelReg->ac_ptr = pChannelData->n_start;
		pChannelReg->ac_len = pChannelData->n_reallength;
		pChannelReg->ac_per = uwPeriod;
		mt_dmaon |= pChannelData->uwDmaFlag;
	}
	checkmorefx(uwCmd, uwCmdArg, pChannelData, pChannelReg);
}

static void set_finetune(
	UWORD uwCmd, UWORD uwCmdArg, UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// logWrite("Set finetune\n");
	UBYTE ubFineTune = uwCmdArg & 0xF;
	pChannelData->pPeriodTable = mt_PeriodTables[ubFineTune];
	pChannelData->n_minusft = ubFineTune >= 8;
	set_period(uwCmd, uwCmdArg, uwMaskedCmdE, pVoice, pChannelData, pChannelReg);
}

static void set_sampleoffset(
	UWORD uwCmd, UWORD uwCmdArg, UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// logWrite("set_sampleoffset\n");
	// cmd 9 x y (xy = offset in 256 bytes)
	// d4 = xy
	mt_sampleoffset(uwCmdArg, pChannelData, pChannelReg);
	set_period(uwCmd, uwCmdArg, uwMaskedCmdE, pVoice, pChannelData, pChannelReg);
}

static void set_toneporta(
	UNUSED_ARG UWORD uwCmd, UNUSED_ARG UWORD uwCmdArg,
	UNUSED_ARG UWORD uwMaskedCmdE, const tModVoice *pVoice,
	tChannelStatus *pChannelData, volatile tChannelRegs *pChannelReg
) {
	// Find first period which is less or equal the note in d6
	UWORD uwNote = pVoice->uwNote & 0xFFF;
	UBYTE ubPeriodPos = findPeriod(mt_PeriodTables[0], uwNote);
	// Original ASM code does something similar, but without those lines it sounds accurate and not out-of-tune
	// if(ubPeriodPos) {
	// 	// One before for less/equal
	// 	--ubPeriodPos;
	// }

	// if(pChannelData->n_minusft && ubPeriodPos) {
	// 	// Negative fine tune? Then take the previous period.
	// 	--ubPeriodPos;
	// }

	// Note offset in period table
	pChannelData->n_noteoff = ubPeriodPos * 2;
	UWORD uwPeriod = pChannelData->uwPeriod;
	UWORD uwNewPeriod = pChannelData->pPeriodTable[ubPeriodPos];
	if(uwNewPeriod == uwPeriod) {
		uwNewPeriod = 0;
	}
	pChannelData->n_wantedperiod = uwNewPeriod;

	if(pChannelData->uwFunkSpeed) {
		mt_updatefunk(pChannelData);
	}

	pChannelReg->ac_per = uwPeriod;
}

static const tPreFx prefx_tab[16] = {
	[0 ... 2] = set_period,
	[3] = set_toneporta,
	[4] = set_period,
	[5] = set_toneporta,
	[6 ... 8] = set_period,
	[9] = set_sampleoffset,
	[0xA ... 0xF] = set_period,
};

/**
 * @brief Get the Paula's Clock Constant.
 *
 * http://amigadev.elowar.com/read/ADCD_2.1/Hardware_Manual_guide/node00DE.html
 *
 * @return The current clock constant, dependent on PAL/NTSC mode.
 */
static inline ULONG getClockConstant() {
	return s_isPal ? 3546895 : 3579545;
}

void ptplayerProcess(void) {
#if defined(PTPLAYER_DEFER_INTERRUPTS)
	if(s_isPendingPlay) {
		s_isPendingPlay = 0;
		intPlay();
	}
	if(s_isPendingDmaOn) {
		s_isPendingDmaOn = 0;
		intDmaOn();
	}
	if(s_isPendingSetRep) {
		s_isPendingSetRep = 0;
		intSetRep(g_pCustom);
	}
#endif
}

const tModVoice *ptplayerGetCurrentVoices(void) {
	UBYTE *pPatternData = mt_mod->pPatterns;
	UBYTE *pArrangement = mt_mod->pArrangement;
	UBYTE ubPatternIdx = pArrangement[mt_SongPos];
	UBYTE *pCurrentPattern = &pPatternData[ubPatternIdx * 1024];
	tModVoice *pLineVoices = (tModVoice*)&pCurrentPattern[mt_PatternPos];
	return pLineVoices;
}

void ptplayerGetVoiceProgress(UWORD *pCurr, UWORD *pMax) {
	*pCurr = mt_Counter;
	*pMax = mt_Speed;
}

void ptplayerEnableMusic(UBYTE isEnabled) {
	mt_Enable = isEnabled;
	s_isNextTimerBSetRep = 0;
}

UBYTE ptplayerGetE8(void) {
	return mt_E8Trigger;
}

void ptplayerReserveChannelsForMusic(UBYTE ubChannelCount) {
	mt_MusicChannels = ubChannelCount;
}

void ptplayerSetSampleVolume(UBYTE ubSampleIndex, UBYTE ubVolume) {
	mt_mod->pSampleHeaders[ubSampleIndex].ubVolume = ubVolume;
}

tPtplayerMod *ptplayerModCreateFromPath(const char *szPath) {
	return ptplayerModCreateFromFd(diskFileOpen(szPath, "rb"));
}

tPtplayerMod *ptplayerModCreateFromFd(tFile *pFileMod) {
	logBlockBegin("ptplayerModCreateFromFd(pFileMod: %p)", pFileMod);

	tPtplayerMod *pMod = 0;
	LONG lSize = fileGetSize(pFileMod);
	if(lSize <= 0) {
		logWrite("ERR: File doesn't exist\n");
		goto fail;
	}

	pMod = memAllocFastClear(sizeof(*pMod));
	if(!pMod) {
		return 0;
	}

	// Read header
	fileRead(pFileMod, pMod->szSongName, sizeof(pMod->szSongName));
	// TODO: read samples data field by field for portability
	fileRead(pFileMod, pMod->pSampleHeaders, sizeof(pMod->pSampleHeaders));
	fileRead(pFileMod, &pMod->ubArrangementLength, sizeof(pMod->ubArrangementLength));
	fileRead(pFileMod, &pMod->ubSongEndPos, sizeof(pMod->ubSongEndPos));
	fileRead(pFileMod, pMod->pArrangement, sizeof(pMod->pArrangement));
	fileRead(pFileMod, pMod->pFileFormatTag, sizeof(pMod->pFileFormatTag));

	// Get number of highest pattern
	UBYTE ubLastPattern = 0;
	for(UBYTE i = 0; i < 127; ++i) {
		if(pMod->pArrangement[i] > ubLastPattern) {
			ubLastPattern = pMod->pArrangement[i];
		}
	}
	UBYTE ubPatternCount = ubLastPattern + 1;
	logWrite("Pattern count: %hhu\n", ubPatternCount);

	// Read pattern data
	pMod->ulPatternsSize = (ubPatternCount * MOD_PATTERN_LENGTH);
	pMod->pPatterns = memAllocFast(pMod->ulPatternsSize);
	if(!pMod->pPatterns) {
		logWrite("ERR: Couldn't allocate memory for pattern data");
		goto fail;
	}
	fileRead(pFileMod, pMod->pPatterns, pMod->ulPatternsSize);

	// Read sample data
	ULONG ulSampleStartPos = fileGetPos(pFileMod);
	ULONG ulSamplesSize = lSize - ulSampleStartPos;
	if(ulSamplesSize) {
		for(UBYTE ubSampleIndex = 0; ubSampleIndex < PTPLAYER_MOD_SAMPLE_COUNT; ++ubSampleIndex) {
			ULONG ulSampleDataLength = pMod->pSampleHeaders[ubSampleIndex].uwLength * sizeof(UWORD);
			if(ulSampleDataLength) {
				pMod->pSampleStarts[ubSampleIndex] = memAllocChip(ulSampleDataLength);
				fileRead(pFileMod, pMod->pSampleStarts[ubSampleIndex], ulSampleDataLength);
			}
		}
		pMod->isOwningSamples = 1;
	}
	else {
		pMod->isOwningSamples = 0;
		logWrite("MOD has no samples - be sure to pass sample pack to ptplayer\n");
	}

	fileClose(pFileMod);
	logBlockEnd("ptplayerModCreateFromFd()");
	return pMod;
fail:
	if(pMod) {
		if(pMod->pPatterns) {
			memFree(pMod->pPatterns, pMod->ulPatternsSize);
		}
		if(pMod->isOwningSamples) {
			for(UBYTE ubSampleIndex = 0; ubSampleIndex < PTPLAYER_MOD_SAMPLE_COUNT; ++ubSampleIndex) {
				ULONG ulSampleDataLength = pMod->pSampleHeaders[ubSampleIndex].uwLength * sizeof(UWORD);
				if(ulSampleDataLength) {
					memFree(pMod->pSampleStarts[ubSampleIndex], ulSampleDataLength);
				}
			}
		}
		memFree(pMod, sizeof(*pMod));
	}

	fileClose(pFileMod);
	logBlockEnd("ptplayerModCreateFromFd()");
	return 0;
}

void ptplayerModDestroy(tPtplayerMod *pMod) {
	if(s_pModCurr == pMod) {
		ptplayerStop();
	}
	memFree(pMod->pPatterns, pMod->ulPatternsSize);
	if(pMod->isOwningSamples) {
		for(UBYTE ubSampleIndex = 0; ubSampleIndex < PTPLAYER_MOD_SAMPLE_COUNT; ++ubSampleIndex) {
			ULONG ulSampleDataLength = pMod->pSampleHeaders[ubSampleIndex].uwLength * sizeof(UWORD);
			if(ulSampleDataLength) {
				memFree(pMod->pSampleStarts[ubSampleIndex], ulSampleDataLength);
			}
		}
	}
	memFree(pMod, sizeof(*pMod));
}

//-------------------------------------------------------------------------- SFX

tPtplayerSfx *ptplayerSfxCreateFromPath(const char *szPath, UBYTE isFast) {
	return ptplayerSfxCreateFromFd(diskFileOpen(szPath, "rb"), isFast);
}

tPtplayerSfx *ptplayerSfxCreateFromFd(tFile *pFileSfx, UBYTE isFast)
{
	systemUse();
	logBlockBegin("ptplayerSfxCreateFromFd(pFileSfx: %p, isFast: %hhu)", pFileSfx, isFast);
	tPtplayerSfx *pSfx = 0;
	if(!pFileSfx) {
		logWrite("ERR: Null file handle\n");
		goto fail;
	}

	pSfx = memAllocFastClear(sizeof(*pSfx));
	if(!pSfx) {
		goto fail;
	}
	UBYTE ubVersion;
	fileRead(pFileSfx, &ubVersion, sizeof(ubVersion));
	if(ubVersion == 1) {
		fileRead(pFileSfx, &pSfx->uwWordLength, sizeof(pSfx->uwWordLength));
		ULONG ulByteSize = pSfx->uwWordLength * sizeof(UWORD);

		UWORD uwSampleRateHz;
		fileRead(pFileSfx, &uwSampleRateHz, sizeof(uwSampleRateHz));
		pSfx->uwPeriod = (getClockConstant() + uwSampleRateHz/2) / uwSampleRateHz;
		logWrite("Length: %lu, sample rate: %hu, period: %hu\n", ulByteSize, uwSampleRateHz, pSfx->uwPeriod);

		pSfx->pData = isFast ? memAllocFast(ulByteSize) : memAllocChip(ulByteSize);
		if(!pSfx->pData) {
			goto fail;
		}
		fileRead(pFileSfx, pSfx->pData, ulByteSize);

		// Check if pData[0] is zeroed-out - it should be because after sfx playback
		// ptplayer sets the channel playback to looped first word. This should
		// be done on sfx converter side. If your samples are humming after playback,
		// fix your custom conversion tool or use latest ACE tools!
		if(pSfx->pData[0] != 0) {
			logWrite("WARN: SFX's first word isn't zeroed-out - won't work properly with ptplayer\n");
		}
	}
	else {
		logWrite("ERR: Unknown sample format version: %hhu\n", ubVersion);
		goto fail;
	}

	fileClose(pFileSfx);
	logBlockEnd("ptplayerSfxCreateFromFd()");
	systemUnuse();
	return pSfx;

fail:
	if(pFileSfx) {
		fileClose(pFileSfx);
	}
	ptplayerSfxDestroy(pSfx);
	logBlockEnd("ptplayerSfxCreateFromFd()");
	systemUnuse();
	return 0;
}

void ptplayerSfxDestroy(tPtplayerSfx *pSfx) {
	logBlockBegin("ptplayerSfxDestroy(pSfx: %p)", pSfx);
	if(pSfx) {
		for(UBYTE ubChannel = 0; ubChannel < 4; ++ubChannel) {
			if(mt_chan[ubChannel].n_sfxptr == pSfx->pData) {
				// ptplayer doesn't mute its channels after sfx playback to save cycles
				logWrite("channel %hhu is still using the sample - muting...\n", ubChannel);
				g_pCustom->aud[ubChannel].ac_vol = 0;
				break;
			}
		}

		systemUse();
		if(pSfx->pData) {
			memFree(pSfx->pData, pSfx->uwWordLength * sizeof(UWORD));
		}
		memFree(pSfx, sizeof(*pSfx));
		systemUnuse();
	}
	logBlockEnd("ptplayerSfxDestroy()");
}

/**
 * @brief Activates the sound effect on this channel.
 *
 * A looped sound effect has always highest priority and will
 * replace a previous effect on the same channel. No automatic channel
 * selection will be used.
 *
 * @param pChannel Channel to be used.
 * @param pSfx Sound effect to be played.
 * @param ubVolume Sound volume (0..63) - ignores mod master volume
 * @param ubPriority Playback priority, must be non-zero. The bigger the
 * more important. Set to SFX_PRIORITY_LOOPED for looped sfx.
 */
static void channelSetSfx(
	tChannelStatus *pChannel, const tPtplayerSfx *pSfx, UBYTE ubVolume,
	UBYTE ubPriority
) {
	pChannel->n_sfxptr = pSfx->pData;
	pChannel->uwSfxWordLength = pSfx->uwWordLength;
	pChannel->uwSfxPeriod = pSfx->uwPeriod;
	pChannel->uwSfxVolume = ubVolume;
	pChannel->ubSfxPriority = ubPriority;
}

void ptplayerSfxStopOnChannel(UBYTE ubChannel) {
	g_pCustom->intena = INTF_INTEN;
	tChannelStatus *pChannel = &mt_chan[ubChannel];
	if(pChannel->ubSfxPriority != 0) {
		pChannel->ubSfxPriority = 1;
		pChannel->uwSfxWordLength = 1; // Idle loop
		pChannel->uwSfxPeriod = 108; // Enter idle as quickly as possible
		pChannel->uwSfxVolume = 0;
		if(pChannel->isLooped) {
			// Looped sfx have first empty word skipped to prevent loop glitches
			// - bring it back.
			pChannel->isLooped = 0;
			--pChannel->n_sfxptr;
		}
	}
	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

void ptplayerSfxPlayLooped(
	const tPtplayerSfx *pSfx, UBYTE ubChannel, UBYTE ubVolume
) {
	if(memType(pSfx->pData) == MEMF_FAST) {
		logWrite("ERR: ptplayer only supports samples located in CHIP mem\n");
	}
	g_pCustom->intena = INTF_INTEN;
	tChannelStatus *pChannel = &mt_chan[ubChannel];
	channelSetSfx(pChannel, pSfx, ubVolume, SFX_PRIORITY_LOOPED);
	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

void ptplayerSfxPlay(
	const tPtplayerSfx *pSfx, UBYTE ubChannel, UBYTE ubVolume, UBYTE ubPriority
) {
	if(memType(pSfx->pData) == MEMF_FAST) {
		logWrite("ERR: ptplayer only supports samples located in CHIP mem\n");
	}
	g_pCustom->intena = INTF_INTEN;
	if(ubChannel != PTPLAYER_SFX_CHANNEL_ANY) {
		// Use fixed channel for effect
		tChannelStatus *pChannel = &mt_chan[ubChannel];

		// Priority high enough to replace a present effect on this channel?
		if(ubPriority >= pChannel->ubSfxPriority) {
			channelSetSfx(pChannel, pSfx, ubVolume, ubPriority);
		}
		g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
		return;
	}

	// Did we already calculate the n_freecnt values for all channels?
	if(!mt_SilCntValid && mt_mod) {
		// Look at the next 8 pattern steps to find the longest sequence
		// of silence (no new note or instrument).
		UBYTE ubSteps = 8;

		// remember which channels are not available for sound effects
		UBYTE pMusicOnly[4];
		for(UBYTE ubChannel = 0; ubChannel < 4; ++ubChannel) {
			pMusicOnly[ubChannel] = mt_chan[ubChannel].isOnlyForMusic;
		}

		// reset freecnts for all channels
		mt_chan[0].n_freecnt = 0;
		mt_chan[1].n_freecnt = 0;
		mt_chan[2].n_freecnt = 0;
		mt_chan[3].n_freecnt = 0;

		// get pattern pointer
		UBYTE *pPatterns = mt_mod->pPatterns;

		UBYTE ubSongPos = mt_SongPos;
		UWORD uwPatternPos = mt_PatternPos;
		UBYTE isEnd = 0;
		UBYTE *pPatternStart = &pPatterns[
			mt_mod->pArrangement[ubSongPos] * MOD_PATTERN_LENGTH
		];
		tModVoice *pPatternEnd = (tModVoice*)(pPatternStart + MOD_PATTERN_LENGTH);
		tModVoice *pPatternPos = (tModVoice*)(pPatternStart + uwPatternPos);
		do {
			UBYTE ubFreeChannelCnt = 4;

			for(UBYTE ubChannel = 0; ubChannel < 4; ++ubChannel) {
				if(!pMusicOnly[ubChannel]) {
					++mt_chan[ubChannel].n_freecnt;
					if(pPatternPos->uwNote) {
						// The channel at current pattern pos has new note so it's not free
						pMusicOnly[ubChannel] = 1;
					}
				}
				// Skip to next channel
				++pPatternPos;
				ubFreeChannelCnt -= pMusicOnly[ubChannel];
			}

			// break the loop when no channel has any more free pattern steps
			// otherwise break after 8 pattern steps
			isEnd = (ubFreeChannelCnt != 0 || --ubSteps == 0);

			// End of pattern reached? Then load next pattern pointer
			if(!isEnd && pPatternPos >= pPatternEnd) {
				uwPatternPos = 0;
				ubSongPos = (mt_SongPos + 1) & 127;
				if(ubSongPos >= mt_mod->ubArrangementLength) {
					ubSongPos = 0;
				}
				pPatternStart = &pPatterns[
					mt_mod->pArrangement[ubSongPos] * MOD_PATTERN_LENGTH
				];
				pPatternEnd = (tModVoice*)(pPatternStart + MOD_PATTERN_LENGTH);
				pPatternPos = (tModVoice*)pPatternStart;
			}
		} while(!isEnd);
		mt_SilCntValid = 1;
	}

	// Determine which channels are already allocated for sound
	// effects and check if the limit was reached. In this case only
	// replace sound effect channels by higher priority.
	BYTE bFreeChannels = 4 - mt_MusicChannels;
	if(mt_chan[0].ubSfxPriority) {
		bFreeChannels -= 1;
	}
	if(mt_chan[1].ubSfxPriority) {
		bFreeChannels -= 1;
	}
	if(mt_chan[2].ubSfxPriority) {
		bFreeChannels -= 1;
	}
	if(mt_chan[3].ubSfxPriority) {
		bFreeChannels -= 1;
	}
	tChannelStatus *pBestChannel = 0;
	UBYTE ubBestFreeCnt = 0;
	if(bFreeChannels >= 0) {
		// Exclude channels which have set a repeat loop. Try not to break them!
		// We will prefer a music channel which had pDoneBit set, because that means
		// the last instrument sample has been played completely, and the channel
		// is now idle.
		UWORD uwChannelsToCheck = 0;
		UWORD uwChannelsNonLooped = 0;
		UWORD uwIntFlag = INTF_AUD0;
		for(UBYTE i = 0; i < 4; ++i) {
			if(!mt_chan[i].isLooped) {
				uwChannelsNonLooped |= uwIntFlag;
				if(isChannelDone(&mt_chan[i])) {
					uwChannelsToCheck |= uwIntFlag;
				}
			}
			uwIntFlag <<= 1;
		}

		if(!uwChannelsToCheck) {
			// All channels are busy, then break the non-looped ones first...
			uwChannelsToCheck = uwChannelsNonLooped;
		}

		if(!uwChannelsToCheck) {
			// ...except there are none. Then it doesn't matter.
			uwChannelsToCheck = INTF_AUD0 | INTF_AUD1 | INTF_AUD2 | INTF_AUD3;
		}

		// First look for the best unused channel
		uwIntFlag = INTF_AUD0;
		for(UBYTE i = 0; i < 4; ++i) {
			if((uwChannelsToCheck & uwIntFlag) && !mt_chan[i].ubSfxPriority) {
				// When all channels freecnt is 0, use any - otherwise it won't play
				if(mt_chan[i].n_freecnt >= ubBestFreeCnt) {
					ubBestFreeCnt = mt_chan[i].n_freecnt;
					pBestChannel = &mt_chan[i];
				}
			}
			uwIntFlag <<= 1;
		}
	}
	if(!ubBestFreeCnt) {
		// All channels reserved/playing effects.
		// Finally try to overwrite a sound effect with lower/equal priority.
		UBYTE ubBestFreeCnt = 0;
		for(UBYTE i = 0; i < 4; ++i) {
			if(
				0 < mt_chan[i].ubSfxPriority && mt_chan[i].ubSfxPriority < ubPriority &&
				mt_chan[i].n_freecnt > ubBestFreeCnt
			) {
				ubBestFreeCnt = mt_chan[i].n_freecnt;
				pBestChannel = &mt_chan[i];
			}
		}
	}
	if(pBestChannel) {
#if defined(ACE_DEBUG_PTPLAYER)
	logWrite("Selected channel %ld for sfx playback\n", pBestChannel - mt_chan);
#endif
		channelSetSfx(pBestChannel, pSfx, ubVolume, ubPriority);
	}
	g_pCustom->intena = INTF_SETCLR | INTF_INTEN;
}

void ptplayerWaitForSfx(void) {
	UBYTE isAnyChannelBusy;
	do {
		isAnyChannelBusy = 0;
		for(UBYTE i = 0; i < 4; ++i) {
			// Wait only for sfx to end - mod is looping ad infinitum anyway.
			if(mt_chan[i].ubSfxPriority) {
				logWrite("sfx ptplayerWaitForSfx\n");
				// channel is busy by sfx
				isAnyChannelBusy = 1;
				// logWrite("channel busy %hhu", i);
				break;
			}
		}
	} while(isAnyChannelBusy);
}

void ptplayerConfigureSongRepeat(UBYTE isRepeat, tPtplayerCbSongEnd cbSongEnd) {
	s_isRepeat = isRepeat;
	s_cbSongEnd = cbSongEnd;
}

UBYTE ptplayerSfxLengthInFrames(const tPtplayerSfx *pSfx) {
	// Get rounded sampling rate.
	UWORD uwSamplingRateHz = (getClockConstant() + (pSfx->uwPeriod / 2)) / pSfx->uwPeriod;
	// Get frame count - round it up.
	UWORD uwFrameCount = (pSfx->uwWordLength * 2 * 50 + uwSamplingRateHz - 1) / uwSamplingRateHz;
	return uwFrameCount;
}

tPtplayerSamplePack *ptplayerSampleDataCreateFromPath(const char *szPath) {
	return ptplayerSampleDataCreateFromFd(diskFileOpen(szPath, "rb"));
}

tPtplayerSamplePack *ptplayerSampleDataCreateFromFd(tFile *pFileSamples)
{
	// TODO: add some kind of header for the file, read each sample separately
	logBlockBegin("ptplayerSampleDataCreateFromFd(pFileSamples: %p)", pFileSamples);
	systemUse();
	tPtplayerSamplePack *pSamplePack = 0;
	LONG lSize = fileGetSize(pFileSamples);
	if(lSize <= 0) {
		logWrite("ERR: Invalid file size. File exists?\n");
		goto fail;
	}

	pSamplePack = memAllocFastClear(sizeof(*pSamplePack));
	logWrite("Addr: %p\n", pSamplePack);
	pSamplePack->ulSize = lSize;
	pSamplePack->pData = memAllocChip(pSamplePack->ulSize);
	if(!pSamplePack->pData) {
		goto fail;
	}

	fileRead(pFileSamples, pSamplePack->pData, pSamplePack->ulSize);
	fileClose(pFileSamples);

	systemUnuse();
	logBlockEnd("ptplayerSampleDataCreateFromFd()");
	return pSamplePack;
fail:
	if(pFileSamples) {
		fileClose(pFileSamples);
	}
	if(pSamplePack) {
		if(pSamplePack->pData) {
			memFree(pSamplePack->pData, pSamplePack->ulSize);
		}
		memFree(pSamplePack, sizeof(*pSamplePack));
	}

	systemUnuse();
	logBlockEnd("ptplayerSampleDataCreateFromFd()");
	return 0;
}

void ptplayerSamplePackDestroy(tPtplayerSamplePack *pSamplePack) {
	logBlockBegin("ptplayerSamplePackDestroy(pSamplePack: %p)", pSamplePack);
	memFree(pSamplePack->pData, pSamplePack->ulSize);
	memFree(pSamplePack, sizeof(*pSamplePack));
	logBlockEnd("ptplayerSamplePackDestroy()");
}
